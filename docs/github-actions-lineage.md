# GitHub Actions Integration Guide

## Overview

Funcqc provides comprehensive GitHub Actions integration for automated lineage detection, validation, and management. This guide covers setup, configuration, and best practices for integrating lineage tracking into your CI/CD workflows.

## Available Workflows

### 1. Lineage Analysis (PR Integration)
**File**: `.github/workflows/lineage-analysis.yml`
- **Trigger**: Pull requests to main/develop branches
- **Purpose**: Automatic lineage detection and PR commenting
- **Output**: Detailed lineage analysis in PR comments

### 2. Lineage Management (Maintenance)
**File**: `.github/workflows/lineage-management.yml`  
- **Trigger**: Manual dispatch, scheduled weekly cleanup
- **Purpose**: Validation, cleanup, health monitoring
- **Output**: Reports, artifacts, GitHub issues for problems

### 3. Lineage Validation (CI Integration)
**Job**: `lineage-validation` in `.github/workflows/ci.yml`
- **Trigger**: Pushes to main branch
- **Purpose**: Ensure lineage system health
- **Output**: Validation status in CI checks

---

## Quick Setup

### Step 1: Add Workflow Files

Create the workflow files in your repository:

```bash
mkdir -p .github/workflows
```

Copy the workflow files from funcqc repository or use the provided templates below.

### Step 2: Configure Permissions

Ensure your repository has the following permissions configured in the workflow files:

```yaml
permissions:
  contents: read      # Repository access
  pull-requests: write # PR commenting
  issues: write       # Issue creation
  actions: write      # Artifact uploads
```

### Step 3: Test the Integration

1. Create a pull request with function changes
2. Verify the lineage analysis workflow runs
3. Check for lineage analysis comments in the PR
4. Test manual workflow dispatch

---

## Workflow Details

## Lineage Analysis Workflow

### Trigger Configuration
```yaml
on:
  pull_request:
    branches: [ main, develop ]
    types: [opened, synchronize, reopened]
```

### Key Features
- **Automatic Detection**: Runs on every PR update
- **Comprehensive Analysis**: Compares base and head commits
- **Rich Reporting**: Detailed lineage analysis in PR comments
- **Artifact Storage**: Saves analysis results for 30 days

### Workflow Steps

1. **Environment Setup**
   - Checkout PR branch with full history
   - Setup Node.js and install dependencies
   - Build project

2. **Base Analysis**
   ```bash
   git checkout ${{ github.event.pull_request.base.sha }}
   funcqc scan --label "base-${{ github.event.pull_request.base.sha }}"
   ```

3. **PR Analysis**
   ```bash
   git checkout ${{ github.event.pull_request.head.sha }}
   funcqc scan --label "pr-${{ github.event.pull_request.head.sha }}"
   ```

4. **Lineage Generation**
   ```bash
   funcqc diff base-commit pr-commit --lineage --json
   ```

5. **PR Commenting**
   - Parse lineage analysis results
   - Generate markdown report
   - Create or update PR comment
   - Handle no-changes scenarios

### Example PR Comment Output

```markdown
# 🔄 Function Lineage Analysis Report

**PR:** #123 - Refactor user authentication system
**Base:** `abc123def`
**Head:** `def456ghi`

## 📊 Summary

| Change Type | Count |
|-------------|-------|
| 🏷️ Rename | 2 |
| ✏️ Signature Change | 1 |
| 🔄 Split | 0 |
| 📎 Inline | 1 |
| **Total** | **4** |

## 🔍 Detected Changes

### RENAME: authenticateUser → validateUserCredentials

- **Confidence:** 92%
- **From:** src/auth/auth.ts:45
- **To:** src/auth/validation.ts:32

### SIGNATURE-CHANGE: hashPassword → hashPassword

- **Confidence:** 85%
- **From:** src/auth/crypto.ts:78 (2 params)
- **To:** src/auth/crypto.ts:78 (3 params)

### INLINE: logAuthAttempt → validateUserCredentials

- **Confidence:** 78%
- **From:** src/auth/logging.ts:15
- **To:** src/auth/validation.ts:45

---
*Generated by funcqc lineage analysis*
```

---

## Lineage Management Workflow

### Manual Actions

The workflow supports four manual actions via `workflow_dispatch`:

#### 1. Validate All (`validate-all`)
- Validates all lineage records for consistency
- Checks for invalid references and data integrity
- Creates GitHub issues for problems found
- **Default action** for manual runs

#### 2. Cleanup Drafts (`cleanup-drafts`)
- Removes old draft lineages (configurable age)
- Helps maintain database performance
- Provides cleanup summary

#### 3. Export Report (`export-report`)
- Generates comprehensive lineage exports
- Creates JSON, text, and CSV formats
- Useful for documentation and analysis

#### 4. Health Check (`health-check`)
- Generates detailed system health report
- Analyzes lineage data quality
- Provides recommendations

### Scheduled Execution

Runs automatically every Sunday at 2 AM UTC:
```yaml
schedule:
  - cron: '0 2 * * 0'  # Weekly cleanup
```

### Manual Execution Examples

```bash
# Trigger via GitHub CLI
gh workflow run lineage-management.yml -f action=validate-all

# Cleanup old drafts (30+ days)
gh workflow run lineage-management.yml -f action=cleanup-drafts -f days_old=30

# Generate export reports
gh workflow run lineage-management.yml -f action=export-report

# Health check
gh workflow run lineage-management.yml -f action=health-check
```

### Artifact Generation

The workflow automatically generates and uploads:

- **Health Reports** (`health-report.md`)
- **Export Files** (`lineages-export.*`)
- **Summary Logs** (in workflow summary)

**Retention**: 90 days for management artifacts, 30 days for analysis artifacts

---

## CI Integration

### Lineage Validation Job

Added to your existing CI workflow:

```yaml
lineage-validation:
  runs-on: ubuntu-latest
  if: github.event_name == 'push' && github.ref == 'refs/heads/main'
  needs: test
  
  steps:
  - name: Validate lineage system
    run: |
      # Initialize funcqc for validation
      mkdir -p .funcqc
      
      # Basic system validation
      funcqc lineage list --help
      funcqc lineage list --limit 5 || echo "No lineages found (normal for new installations)"
```

### Integration Points

1. **After Tests Pass**: Lineage validation runs only after successful tests
2. **Main Branch Only**: Avoids validation overhead on feature branches  
3. **Health Monitoring**: Ensures lineage system remains functional
4. **Database Accessibility**: Validates table structure and basic operations

---

## Configuration

### Environment Variables

Configure workflow behavior with repository variables:

```yaml
env:
  LINEAGE_AUTO_APPROVE: 'false'           # Auto-approve high-confidence lineages
  LINEAGE_COMMENT_THRESHOLD: '0.7'       # Minimum confidence for PR comments
  LINEAGE_CLEANUP_DAYS: '30'             # Days to retain draft lineages
  LINEAGE_MAX_CANDIDATES: '50'           # Maximum similarity candidates
  LINEAGE_ENABLE_CROSS_FILE: 'true'      # Enable cross-file detection
```

### Repository Secrets

For enhanced integration, configure these secrets:

- `GITHUB_TOKEN`: Automatically provided (default permissions sufficient)
- `FUNCQC_CONFIG`: JSON configuration override (optional)

### Workflow Customization

#### Modify Triggers
```yaml
# Run analysis on specific file changes only
on:
  pull_request:
    branches: [ main ]
    paths: [ 'src/**/*.ts', 'src/**/*.js' ]
```

#### Adjust Analysis Scope
```yaml
# Limit to specific directories
- name: Generate lineage analysis
  run: |
    funcqc diff base pr --lineage --file "src/core/**/*.ts"
```

#### Custom Confidence Thresholds
```yaml
# Higher confidence for production
- name: Generate lineage analysis
  run: |
    funcqc diff base pr --lineage --min-confidence 0.8
```

---

## Best Practices

### Workflow Optimization

#### 1. Selective Execution
```yaml
# Skip analysis for documentation-only changes
- name: Check for code changes
  id: changes
  run: |
    if git diff --name-only ${{ github.event.before }}..${{ github.sha }} | grep -E '\.(ts|js|tsx|jsx)$'; then
      echo "has_code_changes=true" >> $GITHUB_OUTPUT
    else
      echo "has_code_changes=false" >> $GITHUB_OUTPUT
    fi

- name: Generate lineage analysis
  if: steps.changes.outputs.has_code_changes == 'true'
  # ... analysis steps
```

#### 2. Performance Tuning
```yaml
# Reduce analysis scope for large repositories
- name: Generate lineage analysis
  run: |
    funcqc diff base pr --lineage \
      --max-candidates 25 \
      --file "src/**/*.ts" \
      --no-cross-file
```

#### 3. Error Handling
```yaml
# Graceful degradation
- name: Generate lineage analysis
  continue-on-error: true
  run: |
    funcqc diff base pr --lineage || echo "Lineage analysis failed - continuing without lineage data"
```

### Security Considerations

#### 1. Permissions
- Use minimal required permissions
- Avoid `actions: write` unless artifacts are needed
- Consider `pull-requests: write` implications

#### 2. Input Validation
```yaml
# Validate manual inputs
- name: Validate inputs
  if: github.event_name == 'workflow_dispatch'
  run: |
    if [[ ! "${{ github.event.inputs.action }}" =~ ^(validate-all|cleanup-drafts|export-report|health-check)$ ]]; then
      echo "Invalid action specified"
      exit 1
    fi
```

### Monitoring and Alerting

#### 1. Workflow Failures
Set up notifications for workflow failures:
```yaml
- name: Notify on failure
  if: failure()
  uses: actions/github-script@v7
  with:
    script: |
      github.rest.issues.create({
        owner: context.repo.owner,
        repo: context.repo.repo,
        title: '🚨 Lineage Workflow Failed',
        body: `Lineage analysis workflow failed in run #${context.runNumber}`,
        labels: ['bug', 'lineage', 'ci']
      });
```

#### 2. Data Quality Alerts  
```yaml
# Alert on high number of invalid lineages
- name: Check data quality
  run: |
    INVALID_COUNT=$(funcqc lineage list --status draft --json | jq '.total')
    if [ "$INVALID_COUNT" -gt 20 ]; then
      echo "::warning::High number of draft lineages: $INVALID_COUNT"
    fi
```

---

## Troubleshooting

### Common Issues

#### 1. Permission Errors
```
Error: Resource not accessible by integration
```
**Solution**: Add required permissions to workflow:
```yaml
permissions:
  contents: read
  pull-requests: write
  actions: write
```

#### 2. Database Initialization
```
Error: Database not initialized
```
**Solution**: Ensure `.funcqc` directory setup:
```yaml
- name: Setup funcqc database
  run: |
    mkdir -p .funcqc
    echo "Initializing lineage database"
```

#### 3. Large Repository Performance
```
Error: Workflow timeout after 6 hours
```
**Solution**: Optimize analysis scope:
```yaml
- name: Generate lineage analysis
  timeout-minutes: 30
  run: |
    funcqc diff base pr --lineage \
      --max-candidates 25 \
      --file "src/core/**/*.ts"
```

#### 4. Memory Issues
```
Error: Process completed with exit code 137
```
**Solution**: Reduce analysis scope or use pagination:
```yaml
# Split large analysis into chunks
- name: Analyze core functions
  run: funcqc diff base pr --lineage --file "src/core/**"
  
- name: Analyze utility functions  
  run: funcqc diff base pr --lineage --file "src/utils/**"
```

### Debugging

#### Enable Debug Logging
```yaml
env:
  DEBUG: 'funcqc:lineage*'
  FUNCQC_LOG_LEVEL: 'debug'
```

#### Test Workflow Locally
```bash
# Use act to test workflows locally
npm install -g @nektos/act
act pull_request -j lineage-detection
```

#### Manual Testing
```bash
# Test lineage generation manually
git checkout main
funcqc scan --label "test-base"
git checkout feature-branch
funcqc scan --label "test-pr"
funcqc diff test-base test-pr --lineage --json
```

---

## Advanced Configuration

### Multi-Repository Setup

For organizations with multiple repositories:

#### 1. Shared Workflow Templates
Create `.github/workflow-templates/` with reusable workflows:

```yaml
# .github/workflow-templates/funcqc-lineage.yml
name: Lineage Analysis
on:
  pull_request:
    branches: [ main ]

jobs:
  lineage-analysis:
    uses: ./.github/workflows/shared-lineage.yml
    with:
      confidence-threshold: ${{ vars.LINEAGE_CONFIDENCE_THRESHOLD || '0.7' }}
      max-candidates: ${{ vars.LINEAGE_MAX_CANDIDATES || '50' }}
```

#### 2. Organization-wide Settings
```yaml
# Set in organization variables
LINEAGE_CONFIDENCE_THRESHOLD: "0.8"
LINEAGE_ENABLE_CROSS_FILE: "true"
LINEAGE_CLEANUP_SCHEDULE: "0 2 * * 0"
```

### Custom Integrations

#### 1. Slack Notifications
```yaml
- name: Notify Slack
  if: steps.lineage.outputs.total_lineages > 0
  uses: 8398a7/action-slack@v3
  with:
    status: success
    text: |
      🔄 Lineage Analysis Complete
      PR #${{ github.event.pull_request.number }}: ${{ steps.lineage.outputs.total_lineages }} lineages detected
```

#### 2. Jira Integration
```yaml
- name: Create Jira ticket for complex changes
  if: steps.lineage.outputs.total_lineages > 10
  run: |
    curl -X POST "https://company.atlassian.net/rest/api/3/issue" \
      -H "Content-Type: application/json" \
      -d '{
        "fields": {
          "project": {"key": "DEV"},
          "summary": "Complex lineage changes in PR #${{ github.event.pull_request.number }}",
          "description": "Review ${{ steps.lineage.outputs.total_lineages }} function lineages",
          "issuetype": {"name": "Task"}
        }
      }'
```

---

## Migration Guide

### From Manual Process

If you're currently tracking lineages manually:

#### 1. Assess Current Workflow
- Document existing lineage tracking process
- Identify manual steps that can be automated
- Plan gradual transition strategy

#### 2. Parallel Implementation
```yaml
# Run both old and new processes initially
- name: Generate manual lineage (legacy)
  run: ./scripts/generate-lineage.sh
  
- name: Generate automated lineage (new)
  run: funcqc diff base pr --lineage
  
- name: Compare results
  run: ./scripts/compare-lineage-results.sh
```

#### 3. Validation Period
- Run both processes for 2-4 weeks
- Compare results and adjust thresholds
- Train team on new workflow
- Gradually phase out manual process

### From Other Tools

#### Migrating from Custom Solutions
```bash
# Export existing lineage data
./legacy-tool export --format json > legacy-lineages.json

# Convert to funcqc format
node scripts/convert-lineages.js legacy-lineages.json | funcqc lineage import

# Validate migration
funcqc lineage list --status imported
```

---

## Performance Optimization

### Large Repository Strategies

#### 1. Incremental Analysis
```yaml
# Only analyze changed files
- name: Get changed files
  id: changed
  run: |
    CHANGED_FILES=$(git diff --name-only ${{ github.event.before }}..${{ github.sha }} | grep -E '\.(ts|js)$' | tr '\n' ',' | sed 's/,$//')
    echo "files=$CHANGED_FILES" >> $GITHUB_OUTPUT

- name: Targeted lineage analysis
  run: |
    funcqc diff base pr --lineage --file "${{ steps.changed.outputs.files }}"
```

#### 2. Parallel Processing
```yaml
# Split analysis by directory
strategy:
  matrix:
    directory: ['src/core', 'src/utils', 'src/api']
    
steps:
- name: Analyze ${{ matrix.directory }}
  run: |
    funcqc diff base pr --lineage --file "${{ matrix.directory }}/**/*.ts"
```

#### 3. Caching
```yaml
- name: Cache funcqc database
  uses: actions/cache@v3
  with:
    path: .funcqc
    key: funcqc-${{ github.sha }}
    restore-keys: |
      funcqc-${{ github.event.pull_request.base.sha }}
      funcqc-main-
```

---

## Next Steps

1. **Implement Basic Integration**: Start with PR analysis workflow
2. **Monitor and Tune**: Adjust confidence thresholds based on results  
3. **Add Management**: Implement cleanup and validation workflows
4. **Extend Integration**: Add custom notifications and reporting
5. **Scale**: Optimize for your repository size and team workflow

For more advanced configurations and custom integrations, see the [Advanced Integration Examples](./advanced-lineage-integration.md) guide.