import { PGlite } from '@electric-sql/pglite';
import { Kysely } from 'kysely';
import simpleGit, { SimpleGit } from 'simple-git';
import * as path from 'path';
import { readFileSync, existsSync } from 'fs';
import { v4 as uuidv4 } from 'uuid';
import { EmbeddingService } from '../services/embedding-service';
import { ANNConfig } from '../services/ann-index';
import { PGLiteStorageAdapter as PGLiteStorageAdapterRefactored } from './pglite-adapter-refactored';
import {
    FunctionInfo,
    SnapshotInfo,
    StorageAdapter,
    QueryOptions,
    SnapshotMetadata,
    SnapshotDiff,
    FunctionChange,
    ChangeDetail,
    DiffStatistics,
    SnapshotRow,
    FunctionRow,
    ParameterRow,
    MetricsRow,
    ParameterInfo,
    QualityMetrics,
    FunctionDescription,
    NamingEvaluation,
    Lineage,
    LineageKind,
    LineageStatus,
    LineageQuery,
    RefactoringSession,
    RefactoringChangeset,
    RefactoringIntent,
    CallEdge,
    CallEdgeRow,
    InternalCallEdge,
    SourceFile,
    BackupOptions,
} from '../types';
import {
    BatchProcessor,
    TransactionalBatchProcessor,
    BatchTransactionProcessor,
} from '../utils/batch-processor';
// Import separated modules
import { PGliteDialect } from './dialects/pglite-dialect';
import { DatabaseError, hasTestTrackingProperty, isTestTrackingFunction } from './errors/database-error';
import { Database, InternalCallEdgeTable } from './types/kysely-types';
import { ErrorCode } from '../utils/error-handler';

// Re-export for backward compatibility
export { DatabaseError };


import {
    prepareBulkInsertData,
    generateBulkInsertSQL,
    splitIntoBatches,
    calculateOptimalBatchSize,
} from './bulk-insert-utils';


/**
 * Database row types for refactoring health engine
 */
interface RefactoringChangesetRow {
    id: string;
    session_id: string;
    operation_type: string;
    intent: string;
    parent_function_id: string | null;
    child_function_ids: string | string[];
    before_snapshot_id: string;
    after_snapshot_id: string;
    health_assessment: string | null;
    improvement_metrics: string | null;
    is_genuine_improvement: boolean | null;
    function_explosion_score: number | null;
    created_at: string;
    updated_at: string;
}

/**
 * Legacy PGLite storage adapter - now a wrapper around the refactored implementation
 * @deprecated Use PGLiteStorageAdapterRefactored directly
 */
export class PGLiteStorageAdapter implements StorageAdapter {
    private refactoredAdapter: PGLiteStorageAdapterRefactored;

    constructor(dbPath: string, logger?: { log: (msg: string) => void; warn: (msg: string) => void; error: (msg: string) => void }) {
        this.refactoredAdapter = new PGLiteStorageAdapterRefactored(dbPath, logger);

        // Store original path for directory check logic
        this.originalDbPath = dbPath;
        // パスを正規化してキャッシュの一貫性を保証
        this.dbPath = path.resolve(dbPath);
        this.db = new PGlite(dbPath);
        // Kyselyは非同期初期化なので、後でinit()で設定
        this.git = simpleGit();

        // Track connection in tests for proper cleanup
        if (typeof global !== 'undefined' && hasTestTrackingProperty(global, '__TEST_TRACK_CONNECTION__')) {
            const testTracker = global.__TEST_TRACK_CONNECTION__;
            if (isTestTrackingFunction(testTracker)) {
                testTracker(this);
            }
        }
    }

    /**
     * Validates the database path to prevent filesystem pollution
     */
    private validateDbPath(dbPath: string): void {
        if (!dbPath || typeof dbPath !== 'string') {
            throw new DatabaseError(
                ErrorCode.DATABASE_NOT_INITIALIZED,
                'Database path must be a non-empty string'
            );
        }

        // Allow PostgreSQL connection strings
        if (dbPath.startsWith('postgres://') || dbPath.startsWith('postgresql://')) {
            return;
        }

        // Prevent Windows drive letters only (which would create invalid directories)
        const isWindowsDriveOnly = /^[A-Za-z]:$/.test(dbPath);
        if (isWindowsDriveOnly) {
            throw new DatabaseError(
                ErrorCode.DATABASE_NOT_INITIALIZED,
                `Invalid database path: '${dbPath}'. Drive letters alone are not valid database paths. Use a full path like 'C:\\path\\to\\database.db'`
            );
        }

        // Prevent paths with leading/trailing whitespace
        if (dbPath.trim() !== dbPath) {
            throw new DatabaseError(
                ErrorCode.DATABASE_NOT_INITIALIZED,
                `Invalid database path: '${dbPath}'. Path cannot have leading or trailing whitespace`
            );
        }

        // Comprehensive Windows path validation when dealing with file paths
        // Only validate if it's not a connection string
        if (!dbPath.includes('://')) {
            this.validateWindowsFilePath(dbPath);
        }

        // Ensure path has a reasonable length
        if (dbPath.length > 260) {
            // Windows MAX_PATH limit
            throw new DatabaseError(
                ErrorCode.DATABASE_NOT_INITIALIZED,
                `Database path too long: ${dbPath.length} characters. Maximum allowed: 260`
            );
        }
    }

    /**
     * Comprehensive Windows file path validation
     * Checks for all Windows-invalid characters and path patterns when on Windows
     */
    private validateWindowsFilePath(filePath: string): void {
        // Only apply Windows validation on Windows platform or for Windows-style paths
        const isWindowsPath = /^[A-Za-z]:[\\\/]/.test(filePath) || process.platform === 'win32';

        // Allow Unix-style paths on non-Windows platforms
        if (!isWindowsPath && filePath.startsWith('/')) {
            return; // Unix absolute path is valid
        }

        // Allow relative paths with . and .. as they are valid on all platforms
        if (filePath.startsWith('./') || filePath.startsWith('../')) {
            return; // Valid relative paths
        }

        // Allow special paths like :memory: for testing purposes (they will fail at filesystem level if problematic)
        if (filePath.startsWith(':')) {
            // Log warning but allow it - the error will manifest during actual filesystem operations
            this.logger?.warn(`Warning: Path '${filePath}' may not be supported on Windows due to colon character`);
            return;
        }

        // Windows invalid characters: < > " | ? * and control characters (0-31)
        // Exclude colon from this check as we handle it separately
        const invalidChars = /[<>"|?*\x00-\x1f]/;

        // Special handling for drive letters: allow C:\ but not C: alone
        const isDriveWithBackslash = /^[A-Za-z]:[\\\/]/.test(filePath);

        // For Windows paths, check colon usage
        if (isWindowsPath && !isDriveWithBackslash && filePath.includes(':')) {
            throw new DatabaseError(
                ErrorCode.DATABASE_NOT_INITIALIZED,
                `Invalid database path: '${filePath}'. Colon (:) is not allowed in Windows file paths except for drive letters (e.g., C:\\path)`
            );
        }

        // Check for other invalid characters
        const match = filePath.match(invalidChars);
        if (match) {
            const invalidChar = match[0];
            const charCode = invalidChar.charCodeAt(0);
            const charName = charCode < 32 ? `control character (${charCode})` : `'${invalidChar}'`;

            throw new DatabaseError(
                ErrorCode.DATABASE_NOT_INITIALIZED,
                `Invalid database path: '${filePath}'. Contains Windows-invalid character: ${charName}`
            );
        }

        // Only check Windows-specific restrictions for Windows paths
        if (isWindowsPath) {
            // Check for reserved Windows names
            const pathParts = filePath.split(/[\\\/]/);
            const reservedNames = /^(CON|PRN|AUX|NUL|COM[1-9]|LPT[1-9])(\.|$)/i;

            for (const part of pathParts) {
                if (part && reservedNames.test(part)) {
                    throw new DatabaseError(
                        ErrorCode.DATABASE_NOT_INITIALIZED,
                        `Invalid database path: '${filePath}'. Contains reserved Windows name: '${part}'`
                    );
                }
            }

            // Check for trailing periods or spaces in path components (Windows restriction)
            for (const part of pathParts) {
                if (part && part !== '.' && part !== '..' && (part.endsWith('.') || part.endsWith(' '))) {
                    throw new DatabaseError(
                        ErrorCode.DATABASE_NOT_INITIALIZED,
                        `Invalid database path: '${filePath}'. Path component '${part}' cannot end with period or space on Windows`
                    );
                }
            }
        }
    }

    /**
     * Determines if we should check for database directory existence
     * Handles Windows drive letters (C:) and connection strings
     */
    private shouldCheckDatabaseDirectory(originalPath: string): boolean {
        // Skip check for PostgreSQL-style connection strings
        if (originalPath.startsWith('postgres://') || originalPath.startsWith('postgresql://')) {
            return false;
        }

        // For Windows: Check if it's a valid file path (not just a drive letter)
        // Valid examples: C:\path\to\db, /path/to/db, ./relative/path
        // Invalid examples: C:, D:, etc.
        const isWindowsDriveOnly = /^[A-Za-z]:$/.test(originalPath);
        if (isWindowsDriveOnly) {
            return false;
        }

        return true;
    }

    async init(): Promise<void> {
        try {
            // Check if database path exists (only check for directory-based databases)
            if (this.shouldCheckDatabaseDirectory(this.originalDbPath)) {
                const dbDir = path.dirname(this.dbPath);
                if (!existsSync(dbDir)) {
                    throw new DatabaseError(
                        ErrorCode.DATABASE_NOT_INITIALIZED,
                        'Database directory not found. funcqc needs to be initialized first.',
                        new Error(`Database directory does not exist: ${dbDir}`)
                    );
                }
            }

            await this.db.waitReady;

            // Initialize Kysely after PGlite is ready
            const dialect = new PGliteDialect({ database: this.db });
            this.kysely = new Kysely<Database>({ dialect });

            // Use cache to avoid redundant schema initialization
            if (!PGLiteStorageAdapter.schemaCache.has(this.dbPath)) {
                // 同期的にキャッシュに追加して競合を防ぐ
                PGLiteStorageAdapter.schemaCache.set(this.dbPath, true);
                try {
                    await this.createSchema();
                } catch (error) {
                    // エラーが発生した場合はキャッシュから削除
                    PGLiteStorageAdapter.schemaCache.delete(this.dbPath);
                    throw error;
                }
            }
        } catch (error) {
            if (error instanceof DatabaseError) {
                throw error;
            }

            // Check if it's a database not found error
            if (error instanceof Error && error.message.includes('does not exist')) {
                throw new DatabaseError(
                    ErrorCode.DATABASE_NOT_INITIALIZED,
                    'Database not found. funcqc needs to be initialized first.',
                    error
                );
            }

            throw new DatabaseError(
                ErrorCode.DATABASE_CONNECTION_FAILED,
                `Failed to initialize database: ${error instanceof Error ? error.message : String(error)}`,
                error instanceof Error ? error : undefined
            );
        }
    }

    /**
     * Lightweight initialization for read-only commands
     * Optimized for fast startup (target: 2-3 seconds)
     */
    async lightweightInit(): Promise<void> {
        try {
            // Quick existence check only
            if (this.shouldCheckDatabaseDirectory(this.originalDbPath)) {
                const dbDir = path.dirname(this.dbPath);
                if (!existsSync(dbDir)) {
                    throw new DatabaseError(
                        ErrorCode.DATABASE_NOT_INITIALIZED,
                        'Database directory not found. funcqc needs to be initialized first.',
                        new Error(`Database directory does not exist: ${dbDir}`)
                    );
                }
            }

            // Wait for PGlite but don't initialize schema
            await this.db.waitReady;

            // Initialize Kysely with minimal setup
            const dialect = new PGliteDialect({ database: this.db });
            this.kysely = new Kysely<Database>({ dialect });

            // Mark as lightweight initialized (skip full schema validation)
            this.isInitialized = true;

        } catch (error) {
            if (error instanceof DatabaseError) {
                throw error;
            }
            if (error instanceof Error && error.message.includes('does not exist')) {
                throw new DatabaseError(
                    ErrorCode.DATABASE_NOT_INITIALIZED,
                    'Database not found. funcqc needs to be initialized first.',
                    error
                );
            }
            throw new DatabaseError(
                ErrorCode.DATABASE_CONNECTION_FAILED,
                `Failed to initialize database: ${error instanceof Error ? error.message : String(error)}`,
                error instanceof Error ? error : undefined
            );
        }
    }

    async close(): Promise<void> {
        // Guard against invalid context or already closed connections
        if (!this || typeof this !== 'object') {
            return; // Invalid context
        }

        // Always untrack connection first to prevent cleanup loops
        if (typeof global !== 'undefined' && hasTestTrackingProperty(global, '__TEST_UNTRACK_CONNECTION__')) {
            const testUntracker = global.__TEST_UNTRACK_CONNECTION__;
            if (isTestTrackingFunction(testUntracker)) {
                testUntracker(this);
            }
        }

        try {
            // Safely check for database property existence
            const db = this.db;
            if (!db) {
                return; // Already closed or never initialized
            }

            // Check if database is valid and has close method
            if (typeof db === 'object' && db !== null && typeof db.close === 'function') {
                // Check if already closed (if the property exists)
                const isClosed = 'closed' in db ? (db as { closed: boolean }).closed : false;

                if (!isClosed) {
                    await db.close();
                }
            }
        } catch (error) {
            // Silently handle all cleanup errors to prevent test suite disruption
            // Only log non-trivial errors for debugging purposes
            if (error instanceof Error &&
                !error.message.includes('already closed') &&
                !error.message.includes('Cannot read properties') &&
                !error.message.includes('undefined')) {
                console.warn(`Database close warning: ${error.message}`);
            }
        } finally {
            // Clear the reference to prevent further attempts (if context is valid)
            try {
                if (this && typeof this === 'object') {
                    // Set db to null to prevent further close attempts
                    Object.defineProperty(this, 'db', { value: null, writable: true });
                }
            } catch {
                // Ignore cleanup errors
            }
        }
    }

    // ========================================
    // SNAPSHOT OPERATIONS
    // ========================================

    async updateAnalysisLevel(snapshotId: string, level: 'NONE' | 'BASIC' | 'CALL_GRAPH'): Promise<void> {
        await this.ensureInitialized();

        try {
            // First, recalculate snapshot metadata based on actual functions
            // await this.recalculateSnapshotMetadata(snapshotId); // Method moved to refactored adapter

            // Then get current metadata to update analysis level
            const result = await this.db.query('SELECT metadata FROM snapshots WHERE id = $1', [snapshotId]);
            if (result.rows.length === 0) {
                throw new Error(`Snapshot ${snapshotId} not found`);
            }

            const row = result.rows[0] as { metadata: unknown };
            const currentMetadata = typeof row.metadata === 'string'
                ? this.safeJsonParse(row.metadata, {})
                : row.metadata;

            if (typeof currentMetadata !== 'object' || currentMetadata === null) {
                throw new Error(`Invalid metadata for snapshot ${snapshotId}`);
            }
            const metadata = currentMetadata as Record<string, unknown>;
            metadata['analysisLevel'] = level;
            metadata['basicAnalysisCompleted'] = level === 'BASIC' || level === 'CALL_GRAPH';
            metadata['callGraphAnalysisCompleted'] = level === 'CALL_GRAPH';

            // Update metadata
            await this.db.query(
                'UPDATE snapshots SET metadata = $1 WHERE id = $2',
                [JSON.stringify(metadata), snapshotId]
            );
        } catch (error) {
            throw new DatabaseError(
                ErrorCode.STORAGE_WRITE_ERROR,
                `Failed to update analysis level: ${error instanceof Error ? error.message : String(error)}`,
                error instanceof Error ? error : undefined
            );
        }
    }

    /**
     * Get the config hash from the most recent snapshot
     * Returns null if no snapshots exist
     */
    async getLastConfigHash(): Promise<string | null> {
        await this.ensureInitialized();
        try {
            const result = await this.db.query(
                'SELECT config_hash FROM snapshots ORDER BY created_at DESC LIMIT 1'
            );

            if (result.rows.length === 0) {
                return null;
            }

            return (result.rows[0] as { config_hash: string }).config_hash;
        } catch (error) {
            throw new Error(
                `Failed to get last config hash: ${error instanceof Error ? error.message : String(error)}`
            );
        }
    }

    // ========================================
    // FUNCTION OPERATIONS
    // ========================================

    async queryFunctions(options?: QueryOptions): Promise<FunctionInfo[]> {
        await this.ensureInitialized();
        try {
            // Get the latest snapshot for the specified scope
            const snapshotOptions = {
                sort: 'created_at',
                limit: 1,
                ...(options?.scope && { scope: options.scope })
            };
            const snapshots = await this.getSnapshots(snapshotOptions);
            if (snapshots.length === 0) {
                return [];
            }

            // Use the latest snapshot to get functions
            return await this.getFunctions(snapshots[0].id, options);
        } catch (error) {
            throw new Error(
                `Failed to query functions: ${error instanceof Error ? error.message : String(error)}`
            );
        }
    }

    async storeFunctions(functions: FunctionInfo[], snapshotId: string): Promise<void> {
        await this.ensureInitialized();
        try {
            await this.executeInTransaction(async () => {
                await this.saveFunctions(snapshotId, functions);
            });
        } catch (error) {
            throw new DatabaseError(
                ErrorCode.STORAGE_WRITE_ERROR,
                `Failed to store functions: ${error instanceof Error ? error.message : String(error)}`,
                error instanceof Error ? error : undefined
            );
        }
    }

    // ========================================
    // ANALYSIS OPERATIONS (FUTURE)
    // ========================================

    private categorizeChangedFunctions(
        toFunctions: FunctionInfo[],
        fromMap: Map<string, FunctionInfo>,
        added: FunctionInfo[],
        modified: FunctionChange[],
        unchanged: FunctionInfo[]
    ) {
        for (const toFunc of toFunctions) {
            const fromFunc = fromMap.get(toFunc.semanticId);

            if (!fromFunc) {
                added.push(toFunc);
            } else if (fromFunc.astHash !== toFunc.astHash) {
                modified.push({
                    before: fromFunc,
                    after: toFunc,
                    changes: this.calculateFunctionChanges(fromFunc, toFunc),
                });
            } else {
                unchanged.push(toFunc);
            }
        }
    }

    private findRemovedFunctions(
        fromFunctions: FunctionInfo[],
        toMap: Map<string, FunctionInfo>,
        removed: FunctionInfo[]
    ) {
        for (const fromFunc of fromFunctions) {
            if (!toMap.has(fromFunc.semanticId)) {
                removed.push(fromFunc);
            }
        }
    }

    private calculateFunctionChanges(fromFunc: FunctionInfo, toFunc: FunctionInfo): ChangeDetail[] {
        const changes: ChangeDetail[] = [];

        // Compare metrics if both have them
        if (fromFunc.metrics && toFunc.metrics) {
            const metricsToCompare = [
                { key: 'cyclomaticComplexity' as const, name: 'cyclomaticComplexity' },
                { key: 'linesOfCode' as const, name: 'linesOfCode' },
                { key: 'cognitiveComplexity' as const, name: 'cognitiveComplexity' },
                { key: 'parameterCount' as const, name: 'parameterCount' },
            ];

            for (const { key, name } of metricsToCompare) {
                const oldValue = fromFunc.metrics[key];
                const newValue = toFunc.metrics[key];

                if (oldValue !== newValue) {
                    changes.push({
                        field: name,
                        oldValue,
                        newValue,
                        impact: this.calculateChangeImpact(name, oldValue, newValue),
                    });
                }
            }
        }

        // Compare basic properties
        const basicPropsToCompare = [
            { key: 'name' as const },
            { key: 'filePath' as const },
            { key: 'startLine' as const },
            { key: 'endLine' as const },
        ];

        for (const { key } of basicPropsToCompare) {
            const oldValue = fromFunc[key];
            const newValue = toFunc[key];

            if (oldValue !== newValue) {
                changes.push({
                    field: key,
                    oldValue,
                    newValue,
                    impact: 'low',
                });
            }
        }

        return changes;
    }

    private calculateChangeImpact(
        metric: string,
        oldValue: number,
        newValue: number
    ): 'low' | 'medium' | 'high' {
        const diff = Math.abs(newValue - oldValue);
        const relativeChange = diff / Math.max(oldValue, 1);

        switch (metric) {
            case 'cyclomaticComplexity':
            case 'cognitiveComplexity':
                if (diff >= 5 || relativeChange >= 0.5) return 'high';
                if (diff >= 2 || relativeChange >= 0.2) return 'medium';
                return 'low';

            case 'linesOfCode':
                if (diff >= 50 || relativeChange >= 1.0) return 'high';
                if (diff >= 20 || relativeChange >= 0.5) return 'medium';
                return 'low';

            default:
                if (relativeChange >= 0.5) return 'high';
                if (relativeChange >= 0.2) return 'medium';
                return 'low';
        }
    }

    private calculateDiffStatistics(
        fromFunctions: FunctionInfo[],
        toFunctions: FunctionInfo[],
        added: FunctionInfo[],
        removed: FunctionInfo[],
        modified: FunctionChange[]
    ): DiffStatistics {
        const fromMetrics = this.aggregateMetrics(fromFunctions);
        const toMetrics = this.aggregateMetrics(toFunctions);

        return {
            totalChanges: added.length + removed.length + modified.length,
            addedCount: added.length,
            removedCount: removed.length,
            modifiedCount: modified.length,
            complexityChange: toMetrics.avgComplexity - fromMetrics.avgComplexity,
            linesChange: toMetrics.totalLines - fromMetrics.totalLines,
        };
    }

    private aggregateMetrics(functions: FunctionInfo[]): {
        avgComplexity: number;
        totalLines: number;
    } {
        if (functions.length === 0) {
            return { avgComplexity: 0, totalLines: 0 };
        }

        const totalComplexity = functions.reduce(
            (sum, f) => sum + (f.metrics?.cyclomaticComplexity || 1),
            0
        );
        const totalLines = functions.reduce((sum, f) => sum + (f.metrics?.linesOfCode || 0), 0);

        return {
            avgComplexity: totalComplexity / functions.length,
            totalLines,
        };
    }

    // ========================================
    // FUNCTION DESCRIPTION OPERATIONS
    // ========================================

    async saveFunctionDescription(description: FunctionDescription): Promise<void> {
        try {
            await this.db.query(
                `
        INSERT INTO function_descriptions (
          semantic_id, description, source, created_at, updated_at, created_by, ai_model, confidence_score, validated_for_content_id, needs_review, usage_example, side_effects, error_conditions
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, FALSE, $10, $11, $12)
        ON CONFLICT (semantic_id) 
        DO UPDATE SET 
          description = EXCLUDED.description,
          source = EXCLUDED.source,
          updated_at = EXCLUDED.updated_at,
          created_by = EXCLUDED.created_by,
          ai_model = EXCLUDED.ai_model,
          confidence_score = EXCLUDED.confidence_score,
          validated_for_content_id = EXCLUDED.validated_for_content_id,
          needs_review = FALSE,
          usage_example = EXCLUDED.usage_example,
          side_effects = EXCLUDED.side_effects,
          error_conditions = EXCLUDED.error_conditions
      `,
                [
                    description.semanticId,
                    description.description,
                    description.source,
                    new Date(description.createdAt).toISOString(),
                    new Date(description.updatedAt).toISOString(),
                    description.createdBy || null,
                    description.aiModel || null,
                    description.confidenceScore || null,
                    description.validatedForContentId || null,
                    description.usageExample || null,
                    description.sideEffects || null,
                    description.errorConditions || null,
                ]
            );
        } catch (error) {
            throw new Error(
                `Failed to save function description: ${error instanceof Error ? error.message : String(error)}`
            );
        }
    }

    async getFunctionDescription(semanticId: string): Promise<FunctionDescription | null> {
        try {
            const result = await this.db.query(
                'SELECT * FROM function_descriptions WHERE semantic_id = $1',
                [semanticId]
            );

            if (result.rows.length === 0) {
                return null;
            }

            const row = result.rows[0] as {
                semantic_id: string;
                description: string;
                source: string;
                created_at: string;
                updated_at: string;
                created_by?: string;
                ai_model?: string;
                confidence_score?: number;
                validated_for_content_id?: string;
                usage_example?: string;
                side_effects?: string;
                error_conditions?: string;
            };
            return {
                semanticId: row.semantic_id,
                description: row.description,
                source: row.source as 'human' | 'ai' | 'jsdoc',
                createdAt: new Date(row.created_at).getTime(),
                updatedAt: new Date(row.updated_at).getTime(),
                ...(row.created_by && { createdBy: row.created_by }),
                ...(row.ai_model && { aiModel: row.ai_model }),
                ...(row.confidence_score !== null && { confidenceScore: row.confidence_score }),
                ...(row.validated_for_content_id && {
                    validatedForContentId: row.validated_for_content_id,
                }),
                ...(row.usage_example && { usageExample: row.usage_example }),
                ...(row.side_effects && { sideEffects: row.side_effects }),
                ...(row.error_conditions && { errorConditions: row.error_conditions }),
            };
        } catch (error) {
            throw new Error(
                `Failed to get function description: ${error instanceof Error ? error.message : String(error)}`
            );
        }
    }

    async getFunctionsNeedingDescriptions(
        snapshotId: string,
        options?: QueryOptions
    ): Promise<FunctionInfo[]> {
        try {
            // Query functions where:
            // 1. No description exists, OR
            // 2. Function content has changed (content_id differs from validated_for_content_id), OR
            // 3. Description needs review flag is set
            let sql = `
        SELECT 
          f.id, f.semantic_id, f.content_id, f.snapshot_id, f.name, f.display_name, 
          f.signature, f.signature_hash, f.file_path, f.file_hash, f.start_line, f.end_line,
          f.start_column, f.end_column, f.ast_hash, f.context_path, f.function_type, 
          f.modifiers, f.nesting_level, f.is_exported, f.is_async, f.is_generator,
          f.is_arrow_function, f.is_method, f.is_constructor, f.is_static, 
          f.access_modifier, f.source_code, f.created_at,
          q.lines_of_code, q.total_lines, q.cyclomatic_complexity, q.cognitive_complexity,
          q.parameter_count, q.max_nesting_level, q.return_statement_count, q.branch_count,
          q.loop_count, q.try_catch_count, q.async_await_count, q.callback_count,
          q.maintainability_index, q.halstead_volume, q.halstead_difficulty, q.code_to_comment_ratio
        FROM functions f
        LEFT JOIN quality_metrics q ON f.id = q.function_id
        LEFT JOIN function_descriptions d ON f.semantic_id = d.semantic_id
        WHERE f.snapshot_id = $1 
        AND (
          d.semantic_id IS NULL 
          OR d.needs_review = TRUE
          OR (d.validated_for_content_id IS NULL OR d.validated_for_content_id != f.content_id)
        )
      `;

            const params: (string | number)[] = [snapshotId];

            if (options?.limit) {
                sql += ' LIMIT $' + (params.length + 1);
                params.push(options.limit);
            }

            if (options?.offset) {
                sql += ' OFFSET $' + (params.length + 1);
                params.push(options.offset);
            }

            const result = await this.db.query(sql, params);

            // Get parameters for each function
            const functions = await Promise.all(
                result.rows.map(async row => {
                    const parameters = await this.getFunctionParameters((row as FunctionRow).id);
                    return this.mapRowToFunctionInfo(row as FunctionRow & Partial<MetricsRow>, parameters);
                })
            );

            return functions;
        } catch (error) {
            throw new Error(
                `Failed to get functions needing descriptions: ${error instanceof Error ? error.message : String(error)}`
            );
        }
    }

    async searchFunctionsByDescription(
        keyword: string,
        options?: QueryOptions
    ): Promise<FunctionInfo[]> {
        try {
            // Get the latest snapshot
            const snapshots = await this.getSnapshots({ sort: 'created_at', limit: 1 });
            if (snapshots.length === 0) {
                return [];
            }

            let sql = `
        SELECT 
          f.id,
          f.snapshot_id,
          f.start_line,
          f.end_line,
          f.start_column,
          f.end_column,
          f.created_at,
          f.semantic_id,
          f.name,
          f.display_name,
          f.signature,
          f.file_path,
          f.context_path,
          f.function_type,
          f.modifiers,
          f.nesting_level,
          f.is_exported,
          f.is_async,
          f.is_generator,
          f.is_arrow_function,
          f.is_method,
          f.is_constructor,
          f.is_static,
          f.access_modifier,
          f.content_id,
          f.ast_hash,
          f.source_code,
          f.signature_hash,
          f.file_hash,
          f.file_content_hash,
          q.lines_of_code, q.total_lines, q.cyclomatic_complexity, q.cognitive_complexity,
          q.max_nesting_level, q.parameter_count, q.return_statement_count, q.branch_count,
          q.loop_count, q.try_catch_count, q.async_await_count, q.callback_count,
          q.comment_lines, q.code_to_comment_ratio, q.halstead_volume, q.halstead_difficulty,
          q.maintainability_index,
          d.description
        FROM functions f
        LEFT JOIN quality_metrics q ON f.id = q.function_id
        LEFT JOIN function_descriptions d ON f.semantic_id = d.semantic_id
        WHERE f.snapshot_id = $1 AND (
          f.name ILIKE $2 OR 
          f.source_code ILIKE $2 OR
          d.description ILIKE $2
        )
      `;
            const params: (string | number)[] = [snapshots[0].id, `%${keyword}%`];

            // Add pagination
            if (options?.limit) {
                sql += ` LIMIT $${params.length + 1}`;
                params.push(options.limit);
            }

            if (options?.offset) {
                sql += ` OFFSET $${params.length + 1}`;
                params.push(options.offset);
            }

            const result = await this.db.query(sql, params);

            // Get parameters for each function
            const functions = await Promise.all(
                result.rows.map(async row => {
                    const parameters = await this.getFunctionParameters((row as FunctionRow).id);
                    return this.mapRowToFunctionInfo(row as FunctionRow & Partial<MetricsRow>, parameters);
                })
            );

            return functions;
        } catch (error) {
            throw new Error(
                `Failed to search functions by description: ${error instanceof Error ? error.message : String(error)}`
            );
        }
    }

    async getFunctionsWithDescriptions(
        snapshotId: string,
        options?: QueryOptions
    ): Promise<FunctionInfo[]> {
        try {
            let sql = `
        SELECT 
          f.id,
          f.snapshot_id,
          f.start_line,
          f.end_line,
          f.start_column,
          f.end_column,
          f.created_at,
          f.semantic_id,
          f.name,
          f.display_name,
          f.signature,
          f.file_path,
          f.context_path,
          f.function_type,
          f.modifiers,
          f.nesting_level,
          f.is_exported,
          f.is_async,
          f.is_generator,
          f.is_arrow_function,
          f.is_method,
          f.is_constructor,
          f.is_static,
          f.access_modifier,
          f.content_id,
          f.ast_hash,
          f.source_code,
          f.signature_hash,
          f.file_hash,
          f.file_content_hash,
          q.lines_of_code, q.total_lines, q.cyclomatic_complexity, q.cognitive_complexity,
          q.max_nesting_level, q.parameter_count, q.return_statement_count, q.branch_count,
          q.loop_count, q.try_catch_count, q.async_await_count, q.callback_count,
          q.comment_lines, q.code_to_comment_ratio, q.halstead_volume, q.halstead_difficulty,
          q.maintainability_index,
          d.description, d.source, d.created_at, d.updated_at, d.ai_model
        FROM functions f
        LEFT JOIN quality_metrics q ON f.id = q.function_id
        LEFT JOIN function_descriptions d ON f.semantic_id = d.semantic_id
        WHERE f.snapshot_id = $1 AND d.description IS NOT NULL
      `;
            const params: (string | number)[] = [snapshotId];

            // Add pagination
            if (options?.limit) {
                sql += ` LIMIT $${params.length + 1}`;
                params.push(options.limit);
            }

            if (options?.offset) {
                sql += ` OFFSET $${params.length + 1}`;
                params.push(options.offset);
            }

            const result = await this.db.query(sql, params);

            const functions = await Promise.all(
                result.rows.map(async row => {
                    const parameters = await this.getFunctionParameters((row as FunctionRow).id);
                    return this.mapRowToFunctionInfo(row as FunctionRow & Partial<MetricsRow>, parameters);
                })
            );

            return functions;
        } catch (error) {
            throw new Error(
                `Failed to get functions with descriptions: ${error instanceof Error ? error.message : String(error)}`
            );
        }
    }

    async getFunctionsWithoutDescriptions(
        snapshotId: string,
        options?: QueryOptions
    ): Promise<FunctionInfo[]> {
        try {
            let sql = `
        SELECT 
          f.id,
          f.snapshot_id,
          f.start_line,
          f.end_line,
          f.start_column,
          f.end_column,
          f.created_at,
          f.semantic_id,
          f.name,
          f.display_name,
          f.signature,
          f.file_path,
          f.context_path,
          f.function_type,
          f.modifiers,
          f.nesting_level,
          f.is_exported,
          f.is_async,
          f.is_generator,
          f.is_arrow_function,
          f.is_method,
          f.is_constructor,
          f.is_static,
          f.access_modifier,
          f.content_id,
          f.ast_hash,
          f.source_code,
          f.signature_hash,
          f.file_hash,
          f.file_content_hash,
          q.lines_of_code, q.total_lines, q.cyclomatic_complexity, q.cognitive_complexity,
          q.max_nesting_level, q.parameter_count, q.return_statement_count, q.branch_count,
          q.loop_count, q.try_catch_count, q.async_await_count, q.callback_count,
          q.comment_lines, q.code_to_comment_ratio, q.halstead_volume, q.halstead_difficulty,
          q.maintainability_index
        FROM functions f
        LEFT JOIN quality_metrics q ON f.id = q.function_id
        LEFT JOIN function_descriptions d ON f.semantic_id = d.semantic_id
        WHERE f.snapshot_id = $1 AND d.description IS NULL
      `;
            const params: (string | number)[] = [snapshotId];

            // Add pagination
            if (options?.limit) {
                sql += ` LIMIT $${params.length + 1}`;
                params.push(options.limit);
            }

            if (options?.offset) {
                sql += ` OFFSET $${params.length + 1}`;
                params.push(options.offset);
            }

            const result = await this.db.query(sql, params);

            const functions = await Promise.all(
                result.rows.map(async row => {
                    const parameters = await this.getFunctionParameters((row as FunctionRow).id);
                    return this.mapRowToFunctionInfo(row as FunctionRow & Partial<MetricsRow>, parameters);
                })
            );

            return functions;
        } catch (error) {
            throw new Error(
                `Failed to get functions without descriptions: ${error instanceof Error ? error.message : String(error)}`
            );
        }
    }

    // ========================================
    // EMBEDDING OPERATIONS
    // ========================================

    async getFunctionsBatch(functionIds: string[]): Promise<Map<string, FunctionInfo>> {
        if (functionIds.length === 0) {
            return new Map();
        }

        try {
            // Use PostgreSQL array for efficient batch query
            const idsArray = this.formatPostgresArrayLiteral(functionIds);

            const result = await this.db.query(
                `
        SELECT 
          f.id,
          f.snapshot_id,
          f.start_line,
          f.end_line,
          f.start_column,
          f.end_column,
          f.created_at,
          f.semantic_id,
          f.name,
          f.display_name,
          f.signature,
          f.file_path,
          f.context_path,
          f.function_type,
          f.modifiers,
          f.nesting_level,
          f.is_exported,
          f.is_async,
          f.is_generator,
          f.is_arrow_function,
          f.is_method,
          f.is_constructor,
          f.is_static,
          f.access_modifier,
          f.content_id,
          f.ast_hash,
          f.source_code,
          f.signature_hash,
          f.file_hash,
          f.file_content_hash,
          q.lines_of_code, q.total_lines, q.cyclomatic_complexity, q.cognitive_complexity,
          q.max_nesting_level, q.parameter_count, q.return_statement_count, q.branch_count,
          q.loop_count, q.try_catch_count, q.async_await_count, q.callback_count,
          q.comment_lines, q.code_to_comment_ratio, q.halstead_volume, q.halstead_difficulty,
          q.maintainability_index,
          d.description
        FROM functions f
        LEFT JOIN quality_metrics q ON f.id = q.function_id
        LEFT JOIN function_descriptions d ON f.semantic_id = d.semantic_id
        WHERE f.id = ANY($1::text[]) OR f.semantic_id = ANY($1::text[])
      `,
                [idsArray]
            );

            // Get parameters for all functions in a single batch
            const parameterMap = await this.getFunctionParametersBatch(
                result.rows.map(row => (row as FunctionRow).id)
            );

            const functionMap = new Map<string, FunctionInfo>();

            for (const row of result.rows) {
                const functionRow = row as FunctionRow & Partial<MetricsRow>;
                const parameters = parameterMap.get(functionRow.id) || [];
                const functionInfo = this.mapRowToFunctionInfo(functionRow, parameters);

                // Store by both id and semantic_id for flexible lookup
                functionMap.set(functionRow.id, functionInfo);
                functionMap.set(functionRow.semantic_id, functionInfo);
            }

            return functionMap;
        } catch (error) {
            throw new Error(
                `Failed to get functions batch: ${error instanceof Error ? error.message : String(error)}`
            );
        }
    }

    // ========================================
    // RAW DATABASE ACCESS (for debugging and testing)
    // ========================================

    /**
     * Execute raw SQL query (read-only operations only)
     * Used by db command for debugging and testing
     */
    async query(sql: string, params: (string | number)[] = []): Promise<{ rows: unknown[] }> {
        await this.ensureInitialized();

        // Basic safety check - only allow SELECT statements
        const trimmedSql = sql.trim().toUpperCase();
        if (!trimmedSql.startsWith('SELECT')) {
            throw new DatabaseError(
                ErrorCode.STORAGE_ERROR,
                'Only SELECT statements are allowed for raw queries',
                new Error('Attempted non-SELECT query')
            );
        }

        try {
            const result = await this.db.query(sql, params);
            return { rows: result.rows };
        } catch (error) {
            throw new DatabaseError(
                ErrorCode.STORAGE_ERROR,
                `Query execution failed: ${error instanceof Error ? error.message : String(error)}`,
                error instanceof Error ? error : undefined
            );
        }
    }

    // ANN INDEX MANAGEMENT
    // ========================================

    /**
     * Save ANN index metadata and serialized index data
     */
    async saveANNIndex(
        indexId: string,
        config: ANNConfig,
        embeddingModel: string,
        vectorDimension: number,
        vectorCount: number,
        indexData: string,
        buildTimeMs: number,
        accuracyMetrics?: Record<string, unknown>
    ): Promise<void> {
        try {
            // Mark all existing indexes as not current
            await this.db.query('UPDATE ann_index_metadata SET is_current = FALSE');

            // Insert new index metadata
            await this.db.query(
                `
        INSERT INTO ann_index_metadata (
          id, algorithm, config_json, embedding_model, vector_dimension, 
          vector_count, index_data, build_time_ms, accuracy_metrics, is_current
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, TRUE)
        ON CONFLICT (id) DO UPDATE SET
          algorithm = EXCLUDED.algorithm,
          config_json = EXCLUDED.config_json,
          embedding_model = EXCLUDED.embedding_model,
          vector_dimension = EXCLUDED.vector_dimension,
          vector_count = EXCLUDED.vector_count,
          index_data = EXCLUDED.index_data,
          build_time_ms = EXCLUDED.build_time_ms,
          accuracy_metrics = EXCLUDED.accuracy_metrics,
          updated_at = CURRENT_TIMESTAMP,
          is_current = TRUE
      `,
                [
                    indexId,
                    config.algorithm,
                    JSON.stringify(config),
                    embeddingModel,
                    vectorDimension,
                    vectorCount,
                    indexData,
                    buildTimeMs,
                    accuracyMetrics ? JSON.stringify(accuracyMetrics) : null,
                ]
            );
        } catch (error) {
            throw new Error(
                `Failed to save ANN index: ${error instanceof Error ? error.message : String(error)}`
            );
        }
    }

    /**
     * Get current ANN index metadata and data
     */
    async getCurrentANNIndex(): Promise<{
        id: string;
        config: ANNConfig;
        embeddingModel: string;
        vectorDimension: number;
        vectorCount: number;
        indexData: string;
        buildTimeMs: number;
        accuracyMetrics?: Record<string, unknown>;
        createdAt: Date;
        updatedAt: Date;
    } | null> {
        try {
            const result = await this.db.query(`
        SELECT * FROM ann_index_metadata 
        WHERE is_current = TRUE 
        ORDER BY updated_at DESC 
        LIMIT 1
      `);

            if (result.rows.length === 0) {
                return null;
            }

            const row = result.rows[0] as {
                id: string;
                algorithm: string;
                config_json: string;
                embedding_model: string;
                vector_dimension: number;
                vector_count: number;
                index_data: string;
                build_time_ms: number;
                accuracy_metrics: string | null;
                created_at: string;
                updated_at: string;
            };

            return {
                id: row.id,
                config: JSON.parse(row.config_json) as ANNConfig,
                embeddingModel: row.embedding_model,
                vectorDimension: row.vector_dimension,
                vectorCount: row.vector_count,
                indexData: row.index_data,
                buildTimeMs: row.build_time_ms,
                accuracyMetrics: row.accuracy_metrics ? JSON.parse(row.accuracy_metrics) : undefined,
                createdAt: new Date(row.created_at),
                updatedAt: new Date(row.updated_at),
            };
        } catch (error) {
            throw new Error(
                `Failed to get current ANN index: ${error instanceof Error ? error.message : String(error)}`
            );
        }
    }

    /**
     * Get all ANN index metadata (for history/comparison)
     */
    async getAllANNIndexes(): Promise<
        Array<{
            id: string;
            algorithm: string;
            embeddingModel: string;
            vectorCount: number;
            buildTimeMs: number;
            isCurrent: boolean;
            createdAt: Date;
        }>
    > {
        try {
            const result = await this.db.query(`
        SELECT id, algorithm, embedding_model, vector_count, build_time_ms, is_current, created_at
        FROM ann_index_metadata 
        ORDER BY created_at DESC
      `);

            return result.rows.map((row: unknown) => {
                const typedRow = row as {
                    id: string;
                    algorithm: string;
                    embedding_model: string;
                    vector_count: number;
                    build_time_ms: number;
                    is_current: boolean;
                    created_at: string;
                };
                return {
                    id: typedRow.id,
                    algorithm: typedRow.algorithm,
                    embeddingModel: typedRow.embedding_model,
                    vectorCount: typedRow.vector_count,
                    buildTimeMs: typedRow.build_time_ms,
                    isCurrent: typedRow.is_current,
                    createdAt: new Date(typedRow.created_at),
                };
            });
        } catch (error) {
            throw new Error(
                `Failed to get ANN indexes: ${error instanceof Error ? error.message : String(error)}`
            );
        }
    }

    /**
     * Delete ANN index by ID
     */
    async deleteANNIndex(indexId: string): Promise<void> {
        try {
            await this.db.query('DELETE FROM ann_index_metadata WHERE id = $1', [indexId]);
        } catch (error) {
            throw new Error(
                `Failed to delete ANN index: ${error instanceof Error ? error.message : String(error)}`
            );
        }
    }

    /**
     * Get ANN index statistics
     */
    async getANNIndexStats(): Promise<{
        totalIndexes: number;
        currentIndex: {
            algorithm: string;
            vectorCount: number;
            buildTimeMs: number;
            model: string;
        } | null;
        averageBuildTime: number;
    }> {
        try {
            const [totalResult, currentResult, avgResult] = await Promise.all([
                this.db.query('SELECT COUNT(*) as total FROM ann_index_metadata'),
                this.db.query(`
          SELECT algorithm, vector_count, build_time_ms, embedding_model 
          FROM ann_index_metadata 
          WHERE is_current = TRUE
        `),
                this.db.query('SELECT AVG(build_time_ms) as avg_time FROM ann_index_metadata'),
            ]);

            type CurrentIndexRow = {
                algorithm: string;
                vector_count: string | number;
                build_time_ms: string | number;
                embedding_model: string;
            };

            type TotalRow = { total: string };
            type AvgTimeRow = { avg_time: string | null };

            const currentIndex =
                currentResult.rows.length > 0
                    ? (() => {
                        const row = currentResult.rows[0] as CurrentIndexRow;
                        return {
                            algorithm: row.algorithm,
                            vectorCount:
                                typeof row.vector_count === 'string'
                                    ? parseInt(row.vector_count, 10)
                                    : row.vector_count,
                            buildTimeMs:
                                typeof row.build_time_ms === 'string'
                                    ? parseInt(row.build_time_ms, 10)
                                    : row.build_time_ms,
                            model: row.embedding_model,
                        };
                    })()
                    : null;

            const totalRow = totalResult.rows[0] as TotalRow;
            const avgRow = avgResult.rows[0] as AvgTimeRow;

            // Parse and validate numeric values with proper fallbacks
            const totalIndexes = totalRow?.total ? parseInt(totalRow.total, 10) : 0;
            const averageBuildTime = avgRow?.avg_time ? parseFloat(avgRow.avg_time) : 0;

            return {
                totalIndexes: isNaN(totalIndexes) ? 0 : totalIndexes,
                currentIndex,
                averageBuildTime: isNaN(averageBuildTime) ? 0 : averageBuildTime,
            };
        } catch (error) {
            throw new Error(
                `Failed to get ANN index stats: ${error instanceof Error ? error.message : String(error)}`
            );
        }
    }

    // ========================================
    // MAINTENANCE OPERATIONS (FUTURE)
    // ========================================

    // ========================================
    // LINEAGE OPERATIONS
    // ========================================

    private formatPostgresArrayLiteral(ids: string[]): string {
        if (!ids || ids.length === 0) return '{}';
        // PostgreSQL array elements need both backslash and quote escaping
        return `{${ids.map(id => {
            // First escape backslashes, then quotes (critical order for security)
            const escaped = id
                .replace(/\\/g, '\\\\')      // Escape backslashes: \ -> \\
                .replace(/"/g, '\\"');       // Escape quotes: " -> \"
            return `"${escaped}"`;
        }).join(',')}}`;
    }

    async cleanup(): Promise<number> {
        throw new Error('cleanup not implemented yet');
    }

    async backup(): Promise<string> {
        throw new Error('backup not implemented yet');
    }

    async restore(): Promise<void> {
        throw new Error('restore not implemented yet');
    }

    // ========================================
    // TRANSACTION MANAGEMENT
    // ========================================

    /**
     * Execute operations within a database transaction
     * Provides automatic rollback on errors and commit on success
     */
    async executeInTransaction<T>(operation: () => Promise<T>): Promise<T> {
        // Check for nested transactions
        if (this.transactionDepth > 0) {
            throw new Error(
                'Nested transactions are not supported. Use savepoints if nested transaction behavior is needed.'
            );
        }

        this.transactionDepth++;
        await this.db.query('BEGIN');
        try {
            const result = await operation();
            await this.db.query('COMMIT');
            return result;
        } catch (error) {
            await this.db.query('ROLLBACK');
            throw error;
        } finally {
            this.transactionDepth--;
        }
    }

    /**
     * Begin a database transaction manually
     */
    async beginTransaction(): Promise<void> {
        await this.db.query('BEGIN');
    }

    /**
     * Commit the current transaction
     */
    async commitTransaction(): Promise<void> {
        await this.db.query('COMMIT');
    }

    /**
     * Rollback the current transaction
     */
    async rollbackTransaction(): Promise<void> {
        await this.db.query('ROLLBACK');
    }

    // ========================================
    // FUNCTION HISTORY OPERATIONS
    // ========================================

    /**
     * Get function history across all snapshots efficiently
     * This avoids N+1 queries by fetching all data in a single query
     */
    async getFunctionHistory(
        functionId: string,
        options?: {
            limit?: number;
            includeAbsent?: boolean;
        }
    ): Promise<
        Array<{
            snapshot: SnapshotInfo;
            function: FunctionInfo | null;
            isPresent: boolean;
        }>
    > {
        await this.ensureInitialized();
        const limit = options?.limit || 100;
        const includeAbsent = options?.includeAbsent ?? false;

        try {
            // Get all snapshots ordered by creation time
            const snapshots = await this.getSnapshots({ limit });

            if (snapshots.length === 0) {
                return [];
            }

            // Build query to get function data across all snapshots in one go
            const snapshotIds = snapshots.map(s => s.id);
            const placeholders = snapshotIds.map((_, i) => `$${i + 2}`).join(',');

            const functionsResult = await this.db.query(
                `
        SELECT 
          f.id, f.semantic_id, f.content_id, f.snapshot_id, f.name, f.display_name, 
          f.signature, f.signature_hash, f.file_path, f.file_hash, f.start_line, f.end_line,
          f.start_column, f.end_column, f.ast_hash, f.context_path, f.function_type, 
          f.modifiers, f.nesting_level, f.is_exported, f.is_async, f.is_generator,
          f.is_arrow_function, f.is_method, f.is_constructor, f.is_static, 
          f.access_modifier, f.source_code, f.created_at,
          q.lines_of_code, q.total_lines, q.cyclomatic_complexity, q.cognitive_complexity,
          q.max_nesting_level, q.parameter_count, q.return_statement_count, q.branch_count,
          q.loop_count, q.try_catch_count, q.async_await_count, q.callback_count,
          q.comment_lines, q.code_to_comment_ratio, q.halstead_volume, q.halstead_difficulty,
          q.maintainability_index
        FROM functions f
        LEFT JOIN quality_metrics q ON f.id = q.function_id
        WHERE f.snapshot_id IN (${placeholders})
          AND (f.id = $1 OR f.id LIKE $1 || '%')
      `,
                [functionId, ...snapshotIds]
            );

            // Get all function IDs for batch parameter loading
            const functionIds = functionsResult.rows.map(row => (row as FunctionRow).id);

            // Batch load all parameters to avoid N+1 queries
            const parametersMap = new Map<string, ParameterRow[]>();
            if (functionIds.length > 0) {
                const parametersResult = await this.db.query(
                    `SELECT * FROM function_parameters WHERE function_id = ANY($1) ORDER BY position`,
                    [functionIds]
                );

                for (const paramRow of parametersResult.rows) {
                    const param = paramRow as ParameterRow;
                    if (!parametersMap.has(param.function_id)) {
                        parametersMap.set(param.function_id, []);
                    }
                    parametersMap.get(param.function_id)!.push(param);
                }
            }

            // Create a map for quick lookup
            const functionMap = new Map<string, FunctionInfo>();
            for (const row of functionsResult.rows) {
                try {
                    const functionRow = row as FunctionRow & Partial<MetricsRow>;
                    // Get parameters from preloaded map
                    const parameters = parametersMap.get(functionRow.id) || [];
                    const func = this.mapRowToFunctionInfo(functionRow, parameters);
                    // Use snapshot_id from the row to map functions
                    functionMap.set(functionRow.snapshot_id, func);
                } catch (rowError) {
                    console.error('Error processing function row:', rowError);
                    console.error('Row data:', JSON.stringify(row, null, 2));
                    throw rowError;
                }
            }

            // Build history array
            const history = snapshots.map(snapshot => {
                const func = functionMap.get(snapshot.id) || null;
                return {
                    snapshot,
                    function: func,
                    isPresent: !!func,
                };
            });

            // Filter out absent functions if requested
            if (!includeAbsent) {
                return history.filter(h => h.isPresent);
            }

            return history;
        } catch (error) {
            throw new Error(
                `Failed to get function history: ${error instanceof Error ? error.message : String(error)}`
            );
        }
    }

    // ========================================
    // BULK OPERATIONS
    // ========================================

    /**
     * Bulk update quality metrics with transaction support
     */
    async bulkUpdateQualityMetrics(
        updates: Array<{ functionId: string; metrics: QualityMetrics }>
    ): Promise<void> {
        if (updates.length === 0) return;

        const batchSize = BatchProcessor.getOptimalBatchSize(updates.length, 2); // 2KB estimated per metric

        await this.executeInTransaction(async () => {
            const batches = BatchProcessor.batchArray(updates, batchSize);

            for (const batch of batches) {
                for (const { functionId, metrics } of batch) {
                    await this.db.query(
                        `
            UPDATE quality_metrics SET
              lines_of_code = $2, total_lines = $3, cyclomatic_complexity = $4, cognitive_complexity = $5,
              max_nesting_level = $6, parameter_count = $7, return_statement_count = $8, branch_count = $9,
              loop_count = $10, try_catch_count = $11, async_await_count = $12, callback_count = $13,
              comment_lines = $14, code_to_comment_ratio = $15, halstead_volume = $16, halstead_difficulty = $17,
              maintainability_index = $18
            WHERE function_id = $1
          `,
                        [
                            functionId,
                            metrics.linesOfCode,
                            metrics.totalLines,
                            metrics.cyclomaticComplexity,
                            metrics.cognitiveComplexity,
                            metrics.maxNestingLevel,
                            metrics.parameterCount,
                            metrics.returnStatementCount,
                            metrics.branchCount,
                            metrics.loopCount,
                            metrics.tryCatchCount,
                            metrics.asyncAwaitCount,
                            metrics.callbackCount,
                            metrics.commentLines,
                            metrics.codeToCommentRatio,
                            metrics.halsteadVolume || null,
                            metrics.halsteadDifficulty || null,
                            metrics.maintainabilityIndex || null,
                        ]
                    );
                }
            }
        });
    }


    // ========================================
    // PRIVATE HELPER METHODS
    // ========================================

    /**
     * Ensure database is initialized before any operations
     */
    private async ensureInitialized(): Promise<void> {
        if (!this.isInitialized) {
            await this.createSchema();
            this.isInitialized = true;
        }
    }

    private async createSchema(): Promise<void> {
        // Initialize database using migration system
        await this.initializeWithMigrations();
    }

    // Legacy methods removed - schema now loaded from database.sql file



    /**
     * Initialize database schema using migration system
     * Replaces the destructive dropOldTablesIfNeeded approach
     */
    private async initializeWithMigrations(): Promise<void> {
        // First, create base schema from database.sql if no tables exist
        const result = await this.db.query(`
      SELECT table_name 
      FROM information_schema.tables 
      WHERE table_schema = 'public' AND table_name = 'snapshots'
    `);

        if (result.rows.length === 0) {
            // Create initial schema from database.sql
            await this.createTablesDirectly();
        }
    }


    /**
     * Create tables directly using database.sql
     */
    private async createTablesDirectly(): Promise<void> {
        const schemaPath = new URL('../schemas/database.sql', import.meta.url).pathname;

        try {
            // Check if tables already exist
            const result = await this.db.query(`
        SELECT table_name 
        FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'snapshots'
      `);

            if (result.rows.length > 0) {
                // Database schema already exists - skip creation without logging
                // to avoid stdout contamination in JSON output
                return;
            }

            const schemaContent = readFileSync(schemaPath, 'utf-8');
            await this.db.exec(schemaContent);
            // Database schema creation completed - no logging to avoid stdout contamination
        } catch (error) {
            this.logger?.error(`❌ Failed to create database schema: ${error}`);
            throw new Error(`Database schema creation failed: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    private async saveSingleFunction(func: FunctionInfo, snapshotId: string): Promise<void> {
        await this.insertFunctionRecord(func, snapshotId);
        await this.insertFunctionParameters(func);
        await this.insertFunctionMetrics(func);
    }

    async saveFunctionsBatch(snapshotId: string, functions: FunctionInfo[]): Promise<void> {
        // Use bulk insert for better performance when batch size is large enough
        if (functions.length >= 10) {
            await this.saveFunctionsBulk(snapshotId, functions);
        } else {
            // Fall back to individual inserts for small batches
            const executeIndividualInserts = async () => {
                for (const func of functions) {
                    await this.saveSingleFunction(func, snapshotId);
                }
            };

            // Execute within transaction only if not already in one
            if (this.transactionDepth > 0) {
                // Already in transaction, execute directly
                await executeIndividualInserts();
            } else {
                // Not in transaction, create new one
                await this.executeInTransaction(executeIndividualInserts);
            }
        }
    }

    /**
     * Bulk insert functions for optimal performance
     */
    private async saveFunctionsBulk(snapshotId: string, functions: FunctionInfo[]): Promise<void> {
        const executeBulkInsert = async () => {
            const bulkData = prepareBulkInsertData(functions, snapshotId);

            // Bulk insert functions
            if (bulkData.functions.length > 0) {
                const functionColumns = [
                    'id',
                    'semantic_id',
                    'content_id',
                    'snapshot_id',
                    'name',
                    'display_name',
                    'signature',
                    'signature_hash',
                    'file_path',
                    'file_hash',
                    'start_line',
                    'end_line',
                    'start_column',
                    'end_column',
                    'ast_hash',
                    'context_path',
                    'function_type',
                    'modifiers',
                    'nesting_level',
                    'is_exported',
                    'is_async',
                    'is_generator',
                    'is_arrow_function',
                    'is_method',
                    'is_constructor',
                    'is_static',
                    'access_modifier',
                    'source_code',
                    'source_file_id',
                ];

                const optimalBatchSize = calculateOptimalBatchSize(functionColumns.length);
                const functionBatches = splitIntoBatches(bulkData.functions, optimalBatchSize);

                for (const batch of functionBatches) {
                    const sql = generateBulkInsertSQL('functions', functionColumns, batch.length);
                    const flatParams = batch.flat();
                    await this.db.query(sql, flatParams);
                }
            }

            // Bulk insert parameters
            if (bulkData.parameters.length > 0) {
                const paramColumns = [
                    'function_id',
                    'name',
                    'type',
                    'type_simple',
                    'position',
                    'is_optional',
                    'is_rest',
                    'default_value',
                    'description',
                ];

                const optimalBatchSize = calculateOptimalBatchSize(paramColumns.length);
                const paramBatches = splitIntoBatches(bulkData.parameters, optimalBatchSize);

                for (const batch of paramBatches) {
                    const sql = generateBulkInsertSQL('function_parameters', paramColumns, batch.length);
                    const flatParams = batch.flat();
                    await this.db.query(sql, flatParams);
                }
            }

            // Bulk insert metrics
            if (bulkData.metrics.length > 0) {
                const metricsColumns = [
                    'function_id',
                    'lines_of_code',
                    'total_lines',
                    'cyclomatic_complexity',
                    'cognitive_complexity',
                    'max_nesting_level',
                    'parameter_count',
                    'return_statement_count',
                    'branch_count',
                    'loop_count',
                    'try_catch_count',
                    'async_await_count',
                    'callback_count',
                    'comment_lines',
                    'code_to_comment_ratio',
                    'halstead_volume',
                    'halstead_difficulty',
                    'maintainability_index',
                ];

                const optimalBatchSize = calculateOptimalBatchSize(metricsColumns.length);
                const metricsBatches = splitIntoBatches(bulkData.metrics, optimalBatchSize);

                for (const batch of metricsBatches) {
                    const sql = generateBulkInsertSQL('quality_metrics', metricsColumns, batch.length);
                    const flatParams = batch.flat();
                    await this.db.query(sql, flatParams);
                }
            }
        };

        // Execute within transaction only if not already in one
        if (this.transactionDepth > 0) {
            // Already in transaction, execute directly
            await executeBulkInsert();
        } else {
            // Not in transaction, create new one
            await this.executeInTransaction(executeBulkInsert);
        }
    }

    private async getFunctionParametersBatch(
        functionIds: string[]
    ): Promise<Map<string, ParameterRow[]>> {
        if (functionIds.length === 0) {
            return new Map();
        }

        const idsArray = this.formatPostgresArrayLiteral(functionIds);
        const result = await this.db.query(
            'SELECT * FROM function_parameters WHERE function_id = ANY($1::text[]) ORDER BY function_id, position',
            [idsArray]
        );

        const parameterMap = new Map<string, ParameterRow[]>();

        for (const row of result.rows as ParameterRow[]) {
            const functionId = row.function_id;
            if (!parameterMap.has(functionId)) {
                parameterMap.set(functionId, []);
            }
            parameterMap.get(functionId)!.push(row);
        }

        return parameterMap;
    }

    private createBaseFunctionInfo(row: FunctionRow, parameters: ParameterRow[]): FunctionInfo {
        return {
            id: row.id,
            semanticId: row.semantic_id || '',
            contentId: row.content_id || '',
            name: row.name,
            displayName: row.display_name || row.name,
            signature: row.signature || '',
            signatureHash: row.signature_hash || '',
            filePath: row.file_path,
            fileHash: row.file_hash || '',
            startLine: row.start_line,
            endLine: row.end_line,
            startColumn: row.start_column || 0,
            endColumn: row.end_column || 0,
            astHash: row.ast_hash || '',

            // Enhanced function identification
            ...(row.context_path && Array.isArray(row.context_path) && { contextPath: row.context_path }),
            ...(row.function_type && { functionType: row.function_type }),
            ...(row.modifiers && Array.isArray(row.modifiers) && { modifiers: row.modifiers }),
            ...(row.nesting_level !== undefined && { nestingLevel: row.nesting_level }),

            // Existing function attributes
            isExported: row.is_exported || false,
            isAsync: row.is_async || false,
            isGenerator: row.is_generator || false,
            isArrowFunction: row.is_arrow_function || false,
            isMethod: row.is_method || false,
            isConstructor: row.is_constructor || false,
            isStatic: row.is_static || false,
            parameters: this.mapParameters(parameters),
        };
    }

    private mapParameters(parameters: ParameterRow[]): ParameterInfo[] {
        return parameters.map(p => ({
            name: p.name,
            type: p.type,
            typeSimple: p.type_simple,
            position: p.position,
            isOptional: p.is_optional,
            isRest: p.is_rest,
            ...(p.default_value && { defaultValue: p.default_value }),
            ...(p.description && { description: p.description }),
        }));
    }

    private addOptionalProperties(
        functionInfo: FunctionInfo,
        row: FunctionRow & {
            description?: string;
            source?: string;
            created_at?: string;
            updated_at?: string;
            ai_model?: string;
        }
    ): void {
        if (row.access_modifier) functionInfo.accessModifier = row.access_modifier;
        // Note: js_doc is now stored in function_documentation table
        if (row.source_code) functionInfo.sourceCode = row.source_code;
        if (row.description) {
            functionInfo.description = row.description;
            // Add description metadata as proper properties on the functionInfo object
            if (row.source) functionInfo.descriptionSource = row.source;
            if (row.created_at) functionInfo.descriptionCreatedAt = row.created_at;
            if (row.updated_at) functionInfo.descriptionUpdatedAt = row.updated_at;
            if (row.ai_model) functionInfo.descriptionAiModel = row.ai_model;
        }
    }

    private addMetricsIfAvailable(functionInfo: FunctionInfo, row: Partial<MetricsRow>): void {
        if (row.lines_of_code === null || row.lines_of_code === undefined) return;

        functionInfo.metrics = {
            linesOfCode: row.lines_of_code ?? 0,
            totalLines: row.total_lines ?? 0,
            cyclomaticComplexity: row.cyclomatic_complexity ?? 1,
            cognitiveComplexity: row.cognitive_complexity ?? 0,
            maxNestingLevel: row.max_nesting_level ?? 0,
            parameterCount: row.parameter_count ?? 0,
            returnStatementCount: row.return_statement_count ?? 0,
            branchCount: row.branch_count ?? 0,
            loopCount: row.loop_count ?? 0,
            tryCatchCount: row.try_catch_count ?? 0,
            asyncAwaitCount: row.async_await_count ?? 0,
            callbackCount: row.callback_count ?? 0,
            commentLines: row.comment_lines ?? 0,
            codeToCommentRatio: row.code_to_comment_ratio ?? 0,
            ...this.getOptionalMetrics(row),
        };
    }

    private getOptionalMetrics(row: Partial<MetricsRow>): Partial<QualityMetrics> {
        return {
            ...(row.halstead_volume !== null &&
                row.halstead_volume !== undefined && { halsteadVolume: row.halstead_volume }),
            ...(row.halstead_difficulty !== null &&
                row.halstead_difficulty !== undefined && { halsteadDifficulty: row.halstead_difficulty }),
            ...(row.maintainability_index !== null &&
                row.maintainability_index !== undefined && {
                maintainabilityIndex: row.maintainability_index,
            }),
        };
    }

    // Git helper methods
    private async getGitCommit(): Promise<string | null> {
        try {
            const isRepo = await this.git.checkIsRepo();
            if (!isRepo) return null;

            return await this.git.revparse(['HEAD']);
        } catch {
            return null;
        }
    }

    private async getGitBranch(): Promise<string | null> {
        try {
            const isRepo = await this.git.checkIsRepo();
            if (!isRepo) return null;

            return await this.git.revparse(['--abbrev-ref', 'HEAD']);
        } catch {
            return null;
        }
    }

    private async getGitTag(): Promise<string | null> {
        try {
            const isRepo = await this.git.checkIsRepo();
            if (!isRepo) return null;

            const tags = await this.git.tags(['--points-at', 'HEAD']);
            return tags.latest || null;
        } catch {
            return null;
        }
    }

    // ========================================
    // NAMING EVALUATION OPERATIONS (v1.6 Enhancement)
    // ========================================

    async saveNamingEvaluation(evaluation: NamingEvaluation): Promise<void> {
        try {
            await this.db.query(
                `
        INSERT INTO naming_evaluations (
          function_id, semantic_id, function_name, description_hash, rating,
          evaluated_at, evaluated_by, issues, suggestions, revision_needed,
          ai_model, confidence
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
        ON CONFLICT (function_id) DO UPDATE SET
          semantic_id = EXCLUDED.semantic_id,
          function_name = EXCLUDED.function_name,
          description_hash = EXCLUDED.description_hash,
          rating = EXCLUDED.rating,
          evaluated_at = EXCLUDED.evaluated_at,
          evaluated_by = EXCLUDED.evaluated_by,
          issues = EXCLUDED.issues,
          suggestions = EXCLUDED.suggestions,
          revision_needed = EXCLUDED.revision_needed,
          ai_model = EXCLUDED.ai_model,
          confidence = EXCLUDED.confidence,
          updated_at = CURRENT_TIMESTAMP
      `,
                [
                    evaluation.functionId,
                    evaluation.semanticId,
                    evaluation.functionName,
                    evaluation.descriptionHash,
                    evaluation.rating,
                    evaluation.evaluatedAt,
                    evaluation.evaluatedBy,
                    evaluation.issues || null,
                    evaluation.suggestions || null,
                    evaluation.revisionNeeded,
                    evaluation.aiModel || null,
                    evaluation.confidence || null,
                ]
            );
        } catch (error) {
            throw new Error(
                `Failed to save naming evaluation: ${error instanceof Error ? error.message : String(error)}`
            );
        }
    }

    async getNamingEvaluation(functionId: string): Promise<NamingEvaluation | null> {
        try {
            const queryResult = await this.db.query(
                'SELECT * FROM naming_evaluations WHERE function_id = $1',
                [functionId]
            );

            if (queryResult.rows.length === 0) {
                return null;
            }

            const row = queryResult.rows[0] as {
                function_id: string;
                semantic_id: string;
                function_name: string;
                description_hash: string;
                rating: 1 | 2 | 3;
                evaluated_at: string;
                evaluated_by: 'human' | 'ai' | 'auto';
                issues?: string;
                suggestions?: string;
                revision_needed: boolean;
                ai_model?: string;
                confidence?: number;
            };

            const result: NamingEvaluation = {
                functionId: row.function_id,
                semanticId: row.semantic_id,
                functionName: row.function_name,
                descriptionHash: row.description_hash,
                rating: row.rating,
                evaluatedAt: parseInt(row.evaluated_at),
                evaluatedBy: row.evaluated_by,
                revisionNeeded: row.revision_needed,
            };

            if (row.issues) result.issues = row.issues;
            if (row.suggestions) result.suggestions = row.suggestions;
            if (row.ai_model) result.aiModel = row.ai_model;
            if (row.confidence !== null && row.confidence !== undefined)
                result.confidence = row.confidence;

            return result;
        } catch (error) {
            throw new Error(
                `Failed to get naming evaluation: ${error instanceof Error ? error.message : String(error)}`
            );
        }
    }

    async getFunctionsNeedingEvaluation(
        snapshotId: string,
        options?: QueryOptions
    ): Promise<Array<{ functionId: string; functionName: string; lastModified: number }>> {
        try {
            let sql = `
        SELECT 
          f.id as function_id,
          f.name as function_name,
          EXTRACT(EPOCH FROM f.created_at) * 1000 as last_modified
        FROM functions f
        LEFT JOIN naming_evaluations ne ON f.id = ne.function_id
        WHERE f.snapshot_id = $1 
        AND (
          ne.function_id IS NULL 
          OR ne.revision_needed = TRUE
        )
        ORDER BY f.created_at DESC
      `;

            const params: (string | number)[] = [snapshotId];

            if (options?.limit) {
                sql += ' LIMIT $' + (params.length + 1);
                params.push(options.limit);
            }

            if (options?.offset) {
                sql += ' OFFSET $' + (params.length + 1);
                params.push(options.offset);
            }

            const result = await this.db.query(sql, params);

            return result.rows.map(row => ({
                functionId: (row as { function_id: string }).function_id,
                functionName: (row as { function_name: string }).function_name,
                lastModified: (row as { last_modified: number }).last_modified,
            }));
        } catch (error) {
            throw new Error(
                `Failed to get functions needing evaluation: ${error instanceof Error ? error.message : String(error)}`
            );
        }
    }

    async getFunctionsWithEvaluations(
        snapshotId: string,
        options?: QueryOptions
    ): Promise<Array<{ functionId: string; evaluation: NamingEvaluation }>> {
        try {
            let sql = `
        SELECT 
          f.id as function_id,
          ne.*
        FROM functions f
        INNER JOIN naming_evaluations ne ON f.id = ne.function_id
        WHERE f.snapshot_id = $1
        ORDER BY ne.evaluated_at DESC
      `;

            const params: (string | number)[] = [snapshotId];

            if (options?.limit) {
                sql += ' LIMIT $' + (params.length + 1);
                params.push(options.limit);
            }

            if (options?.offset) {
                sql += ' OFFSET $' + (params.length + 1);
                params.push(options.offset);
            }

            const result = await this.db.query(sql, params);

            return result.rows.map(row => {
                const r = row as {
                    function_id: string;
                    semantic_id: string;
                    function_name: string;
                    description_hash: string;
                    rating: 1 | 2 | 3;
                    evaluated_at: string;
                    evaluated_by: 'human' | 'ai' | 'auto';
                    issues?: string;
                    suggestions?: string;
                    revision_needed: boolean;
                    ai_model?: string;
                    confidence?: number;
                };

                const evaluation: NamingEvaluation = {
                    functionId: r.function_id,
                    semanticId: r.semantic_id,
                    functionName: r.function_name,
                    descriptionHash: r.description_hash,
                    rating: r.rating,
                    evaluatedAt: parseInt(r.evaluated_at),
                    evaluatedBy: r.evaluated_by,
                    revisionNeeded: r.revision_needed,
                };

                if (r.issues) evaluation.issues = r.issues;
                if (r.suggestions) evaluation.suggestions = r.suggestions;
                if (r.ai_model) evaluation.aiModel = r.ai_model;
                if (r.confidence !== null && r.confidence !== undefined)
                    evaluation.confidence = r.confidence;

                return {
                    functionId: r.function_id,
                    evaluation,
                };
            });
        } catch (error) {
            throw new Error(
                `Failed to get functions with evaluations: ${error instanceof Error ? error.message : String(error)}`
            );
        }
    }

    async updateEvaluationRevisionStatus(functionId: string, revisionNeeded: boolean): Promise<void> {
        try {
            await this.db.query(
                'UPDATE naming_evaluations SET revision_needed = $1, updated_at = CURRENT_TIMESTAMP WHERE function_id = $2',
                [revisionNeeded, functionId]
            );
        } catch (error) {
            throw new Error(
                `Failed to update evaluation revision status: ${error instanceof Error ? error.message : String(error)}`
            );
        }
    }

    async batchSaveEvaluations(evaluations: NamingEvaluation[]): Promise<void> {
        if (evaluations.length === 0) return;

        try {
            await TransactionalBatchProcessor.processWithTransaction(
                evaluations,
                {
                    processBatch: async (batch: NamingEvaluation[]) => {
                        const values = batch
                            .map((_, index) => {
                                const offset = index * 12;
                                return `($${offset + 1}, $${offset + 2}, $${offset + 3}, $${offset + 4}, $${offset + 5}, $${offset + 6}, $${offset + 7}, $${offset + 8}, $${offset + 9}, $${offset + 10}, $${offset + 11}, $${offset + 12})`;
                            })
                            .join(', ');

                        const params = batch.flatMap((evaluation: NamingEvaluation) => [
                            evaluation.functionId,
                            evaluation.semanticId,
                            evaluation.functionName,
                            evaluation.descriptionHash,
                            evaluation.rating,
                            evaluation.evaluatedAt,
                            evaluation.evaluatedBy,
                            evaluation.issues || null,
                            evaluation.suggestions || null,
                            evaluation.revisionNeeded,
                            evaluation.aiModel || null,
                            evaluation.confidence || null,
                        ]);

                        await this.db.query(
                            `
              INSERT INTO naming_evaluations (
                function_id, semantic_id, function_name, description_hash, rating,
                evaluated_at, evaluated_by, issues, suggestions, revision_needed,
                ai_model, confidence
              ) VALUES ${values}
              ON CONFLICT (function_id) DO UPDATE SET
                semantic_id = EXCLUDED.semantic_id,
                function_name = EXCLUDED.function_name,
                description_hash = EXCLUDED.description_hash,
                rating = EXCLUDED.rating,
                evaluated_at = EXCLUDED.evaluated_at,
                evaluated_by = EXCLUDED.evaluated_by,
                issues = EXCLUDED.issues,
                suggestions = EXCLUDED.suggestions,
                revision_needed = EXCLUDED.revision_needed,
                ai_model = EXCLUDED.ai_model,
                confidence = EXCLUDED.confidence,
                updated_at = CURRENT_TIMESTAMP
            `,
                            params
                        );
                    },
                    onError: async (error: Error, _batch: NamingEvaluation[]) => {
                        throw error;
                    },
                    onSuccess: async (_batch: NamingEvaluation[]) => {
                        // Success callback
                    },
                },
                10 // Process in batches of 10
            );
        } catch (error) {
            throw new Error(
                `Failed to batch save evaluations: ${error instanceof Error ? error.message : String(error)}`
            );
        }
    }

    async getEvaluationStatistics(snapshotId: string): Promise<{
        total: number;
        withEvaluations: number;
        needingEvaluation: number;
        averageRating: number;
        ratingDistribution: Record<1 | 2 | 3, number>;
    }> {
        try {
            // Get total functions count
            const totalResult = await this.db.query(
                'SELECT COUNT(*) as total FROM functions WHERE snapshot_id = $1',
                [snapshotId]
            );
            const total = Number((totalResult.rows[0] as { total: string | number }).total);

            // Get functions with evaluations
            const evaluationsResult = await this.db.query(
                `
        SELECT 
          COUNT(*) as with_evaluations,
          AVG(ne.rating::numeric) as average_rating,
          SUM(CASE WHEN ne.rating = 1 THEN 1 ELSE 0 END) as rating_1,
          SUM(CASE WHEN ne.rating = 2 THEN 1 ELSE 0 END) as rating_2,
          SUM(CASE WHEN ne.rating = 3 THEN 1 ELSE 0 END) as rating_3
        FROM functions f
        INNER JOIN naming_evaluations ne ON f.id = ne.function_id
        WHERE f.snapshot_id = $1
      `,
                [snapshotId]
            );

            const evalRow = evaluationsResult.rows[0] as {
                with_evaluations: string | number;
                average_rating: string | number;
                rating_1: string | number;
                rating_2: string | number;
                rating_3: string | number;
            };

            // Get functions needing evaluation
            const needingResult = await this.db.query(
                `
        SELECT COUNT(*) as needing_evaluation
        FROM functions f
        LEFT JOIN naming_evaluations ne ON f.id = ne.function_id
        WHERE f.snapshot_id = $1 
        AND (ne.function_id IS NULL OR ne.revision_needed = TRUE)
      `,
                [snapshotId]
            );

            const needingEvaluation = Number(
                (needingResult.rows[0] as { needing_evaluation: string | number }).needing_evaluation
            );

            return {
                total,
                withEvaluations: Number(evalRow.with_evaluations) || 0,
                needingEvaluation,
                averageRating: Number(evalRow.average_rating) || 0,
                ratingDistribution: {
                    1: Number(evalRow.rating_1) || 0,
                    2: Number(evalRow.rating_2) || 0,
                    3: Number(evalRow.rating_3) || 0,
                },
            };
        } catch (error) {
            throw new Error(
                `Failed to get evaluation statistics: ${error instanceof Error ? error.message : String(error)}`
            );
        }
    }

    /**
     * Safely parse JSON with fallback value
     */
    private safeJsonParse<T>(jsonString: string, fallback: T): T {
        try {
            return JSON.parse(jsonString);
        } catch (error) {
            this.logger?.warn(`Failed to parse JSON: ${jsonString} - ${error}`);
            return fallback;
        }
    }

    // ========================================
    // REFACTORING HEALTH ENGINE METHODS
    // ========================================
    // =============================================================================
    // CALL EDGES OPERATIONS
    // =============================================================================

    /**
     * Map database row to CallEdge object
     */
    private mapRowToCallEdge(row: CallEdgeRow): CallEdge {
        return {
            id: row.id,
            callerFunctionId: row.caller_function_id,
            calleeFunctionId: row.callee_function_id || undefined,
            calleeName: row.callee_name,
            calleeSignature: row.callee_signature || undefined,
            callerClassName: row.caller_class_name || undefined,
            calleeClassName: row.callee_class_name || undefined,
            callType: row.call_type,
            callContext: row.call_context || undefined,
            lineNumber: row.line_number,
            columnNumber: row.column_number,
            isAsync: row.is_async,
            isChained: row.is_chained,
            confidenceScore: row.confidence_score,
            metadata: row.metadata,
            createdAt: row.created_at,
        };
    }

    // ========================================
    // SOURCE FILE OPERATIONS (New)
    // ========================================

    /**
     * Save source files for a snapshot with deduplication
     */
    async findExistingSourceFile(compositeId: string): Promise<string | null> {
        try {
            const result = await this.db.query(
                'SELECT id FROM source_files WHERE id = $1 LIMIT 1',
                [compositeId]
            );

            return result.rows.length > 0 ? (result.rows[0] as { id: string }).id : null;
        } catch (error) {
            throw new DatabaseError(
                ErrorCode.STORAGE_ERROR,
                `Failed to check existing source file: ${error instanceof Error ? error.message : String(error)}`,
                error instanceof Error ? error : undefined
            );
        }
    }

    async saveSourceFiles(sourceFiles: import('../types').SourceFile[], snapshotId: string): Promise<void> {
        if (sourceFiles.length === 0) return;

        try {
            // Start transaction for atomic operation
            await this.db.query('BEGIN');

            // Prepare batch insert data
            const insertData = sourceFiles.map(file => [
                file.id,
                snapshotId,
                file.filePath,
                file.fileContent,
                file.fileHash,
                file.encoding,
                file.fileSizeBytes,
                file.lineCount,
                file.language,
                file.functionCount,
                file.exportCount,
                file.importCount,
                file.fileModifiedTime?.toISOString() || null,
            ]);

            // Batch insert source files with conflict handling (deduplication by content hash)
            for (const data of insertData) {
                await this.db.query(
                    `INSERT INTO source_files (
            id, snapshot_id, file_path, file_content, file_hash, encoding,
            file_size_bytes, line_count, language, function_count,
            export_count, import_count, file_modified_time
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
          ON CONFLICT (id) DO UPDATE SET
            snapshot_id = EXCLUDED.snapshot_id,
            file_path = EXCLUDED.file_path,
            file_content = EXCLUDED.file_content,
            file_hash = EXCLUDED.file_hash,
            encoding = EXCLUDED.encoding,
            file_size_bytes = EXCLUDED.file_size_bytes,
            line_count = EXCLUDED.line_count,
            language = EXCLUDED.language,
            function_count = EXCLUDED.function_count,
            export_count = EXCLUDED.export_count,
            import_count = EXCLUDED.import_count,
            file_modified_time = EXCLUDED.file_modified_time`,
                    data
                );
            }

            await this.db.query('COMMIT');

            this.logger?.log(`Saved ${sourceFiles.length} source files for snapshot ${snapshotId}`);
        } catch (error) {
            await this.db.query('ROLLBACK');

            const dbError = new DatabaseError(
                ErrorCode.STORAGE_WRITE_ERROR,
                `Failed to save source files: ${error instanceof Error ? error.message : String(error)}`
            );

            this.logger?.error(`Source files save error: ${dbError.message}`);

            throw dbError;
        }
    }

    /**
     * Get a single source file by ID
     */
    async getSourceFile(id: string): Promise<import('../types').SourceFile | null> {
        try {
            const result = await this.db.query(
                'SELECT * FROM source_files WHERE id = $1',
                [id]
            );

            if (result.rows.length === 0) {
                return null;
            }

            return this.mapRowToSourceFile(result.rows[0] as import('../types').SourceFileRow);
        } catch (error) {
            const dbError = new DatabaseError(
                ErrorCode.STORAGE_ERROR,
                `Failed to get source file: ${error instanceof Error ? error.message : String(error)}`
            );

            this.logger?.error(`Source file retrieval error: ${dbError.message}`);

            throw dbError;
        }
    }

    /**
     * Get a source file by file path for a specific snapshot
     */
    async getSourceFileByPath(filePath: string, snapshotId: string): Promise<import('../types').SourceFile | null> {
        try {
            const result = await this.db.query(
                'SELECT * FROM source_files WHERE file_path = $1 AND snapshot_id = $2',
                [filePath, snapshotId]
            );

            if (result.rows.length === 0) {
                return null;
            }

            return this.mapRowToSourceFile(result.rows[0] as import('../types').SourceFileRow);
        } catch (error) {
            const dbError = new DatabaseError(
                ErrorCode.STORAGE_ERROR,
                `Failed to get source file by path: ${error instanceof Error ? error.message : String(error)}`
            );

            this.logger?.error(`Source file by path retrieval error: ${dbError.message}`);

            throw dbError;
        }
    }

    /**
     * Delete all source files for a snapshot (cleanup operation)
     */
    async deleteSourceFiles(snapshotId: string): Promise<number> {
        try {
            const result = await this.db.query(
                'DELETE FROM source_files WHERE snapshot_id = $1',
                [snapshotId]
            );

            const deletedCount = result.affectedRows || 0;
            this.logger?.log(`Deleted ${deletedCount} source files for snapshot ${snapshotId}`);

            return deletedCount;
        } catch (error) {
            const dbError = new DatabaseError(
                ErrorCode.STORAGE_ERROR,
                `Failed to delete source files: ${error instanceof Error ? error.message : String(error)}`
            );

            this.logger?.error(`Source files deletion error: ${dbError.message}`);

            throw dbError;
        }
    }

    async updateSourceFileFunctionCounts(functionCountByFile: Map<string, number>, snapshotId: string): Promise<void> {
        if (functionCountByFile.size === 0) return;

        try {
            await this.db.query('BEGIN');

            for (const [filePath, functionCount] of functionCountByFile) {
                await this.db.query(
                    'UPDATE source_files SET function_count = $1 WHERE file_path = $2 AND snapshot_id = $3',
                    [functionCount, filePath, snapshotId]
                );
            }

            await this.db.query('COMMIT');
            this.logger?.log(`Updated function counts for ${functionCountByFile.size} files in snapshot ${snapshotId}`);

        } catch (error) {
            await this.db.query('ROLLBACK');

            const dbError = new DatabaseError(
                ErrorCode.STORAGE_WRITE_ERROR,
                `Failed to update source file function counts: ${error instanceof Error ? error.message : String(error)}`
            );

            this.logger?.error(`Source file function count update error: ${dbError.message}`);

            throw dbError;
        }
    }

    // ===== Function Source Code Extraction =====

    /**
     * Extract function source code from stored file content using line/column positions
     */
    async extractFunctionSourceCode(functionId: string): Promise<string | null> {
        try {
            // Get function information first
            const functionResult = await this.db.query(
                'SELECT file_path, snapshot_id, start_line, end_line, start_column, end_column, source_file_id FROM functions WHERE id = $1',
                [functionId]
            );

            if (functionResult.rows.length === 0) {
                return null;
            }

            const func = functionResult.rows[0] as {
                file_path: string;
                snapshot_id: string;
                start_line: number;
                end_line: number;
                start_column: number;
                end_column: number;
                source_file_id: string | null;
            };

            // Get source file content using source_file_id for proper deduplication
            let sourceFileResult;
            if (func.source_file_id) {
                // Preferred approach: use source_file_id directly
                sourceFileResult = await this.db.query(
                    'SELECT file_content FROM source_files WHERE id = $1',
                    [func.source_file_id]
                );
            } else {
                // Fallback: use file_path and snapshot_id (for compatibility with old data)
                sourceFileResult = await this.db.query(
                    'SELECT file_content FROM source_files WHERE file_path = $1 AND snapshot_id = $2',
                    [func.file_path, func.snapshot_id]
                );
            }

            if (sourceFileResult.rows.length === 0) {
                return null;
            }

            const sourceFile = sourceFileResult.rows[0] as { file_content: string };
            const fileContent = sourceFile.file_content;

            return this.extractSourceFromContent(
                fileContent,
                func.start_line,
                func.end_line,
                func.start_column,
                func.end_column
            );

        } catch (error) {
            this.logger?.error(`Failed to extract function source code: ${error instanceof Error ? error.message : String(error)}`);
            return null;
        }
    }

    /**
     * Helper method to map database row to SourceFile object
     */
    private mapRowToSourceFile(row: import('../types').SourceFileRow): import('../types').SourceFile {
        return {
            id: row.id,
            snapshotId: row.snapshot_id,
            filePath: row.file_path,
            fileContent: row.file_content,
            fileHash: row.file_hash,
            encoding: row.encoding,
            fileSizeBytes: row.file_size_bytes,
            lineCount: row.line_count,
            language: row.language,
            functionCount: row.function_count,
            exportCount: row.export_count,
            importCount: row.import_count,
            fileModifiedTime: row.file_modified_time ? new Date(row.file_modified_time) : new Date(),
            createdAt: new Date(row.created_at),
        };
    }

    /**
     * Get direct access to the database connection for advanced operations
     * Returns PGlite instance for direct database access
     * @deprecated Use specific query methods instead of direct database access
     */
    getDb(): PGlite {
        return this.db;
    }

}
